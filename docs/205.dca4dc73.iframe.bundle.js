"use strict";(self.webpackChunk_folio_stripes_components=self.webpackChunk_folio_stripes_components||[]).push([[205],{"./lib/Selection/Selection.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ lib_Selection_Selection)\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__("./node_modules/react/index.js");\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__("./node_modules/prop-types/index.js");\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/prop-types-extra/lib/index.js\nvar lib = __webpack_require__("./node_modules/prop-types-extra/lib/index.js");\n// EXTERNAL MODULE: ./node_modules/react-intl/lib/src/components/useIntl.js\nvar useIntl = __webpack_require__("./node_modules/react-intl/lib/src/components/useIntl.js");\n// EXTERNAL MODULE: ./node_modules/downshift/dist/downshift.esm.js + 1 modules\nvar downshift_esm = __webpack_require__("./node_modules/downshift/dist/downshift.esm.js");\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__("./node_modules/classnames/index.js");\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js\nvar isEqual = __webpack_require__("./node_modules/lodash/isEqual.js");\nvar isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);\n// EXTERNAL MODULE: ./lib/FormField/FormField.js\nvar FormField = __webpack_require__("./lib/FormField/FormField.js");\n// EXTERNAL MODULE: ./lib/FormField/parseMeta.js\nvar parseMeta = __webpack_require__("./lib/FormField/parseMeta.js");\n;// CONCATENATED MODULE: ./lib/Selection/utils.js\n\n\n/* filterOptionList\r\n *   conforms to shapes of options.\r\n *   standard options are { value, label }\r\n *   grouped options are { label, options } where options contains standard options.\r\n */\nconst filterOptionList = (value, dataOptions) => {\n  const valueRE = new RegExp(`^${value}`, \'i\');\n  const baseFilter = o => valueRE.test(o.label);\n  // if items have an \'options\' field, filter those items and return the dataOptions group with the\n  // results inserted.\n  const grouped = dataOptions.some(o => Object.prototype.hasOwnProperty.call(o, \'options\'));\n  if (grouped) {\n    return dataOptions.reduce((options, opt) => {\n      // global, ungrouped options\n      if (Object.prototype.hasOwnProperty.call(opt, \'value\')) {\n        if (valueRE.test(opt.label)) {\n          return [...options, opt];\n        }\n      } else if (Object.prototype.hasOwnProperty.call(opt, \'options\')) {\n        const filteredOptions = opt.options.filter(baseFilter);\n        if (filteredOptions.length > 0) {\n          return [...options, {\n            ...opt,\n            options: filteredOptions\n          }];\n        }\n      }\n      return options;\n    }, []);\n  }\n  return dataOptions.filter(baseFilter);\n};\nconst flattenOptionList = dataOptions => {\n  return dataOptions ? dataOptions.flatMap(opt => {\n    // global, ungrouped options\n    if (Object.prototype.hasOwnProperty.call(opt, \'value\')) {\n      return opt;\n    } else if (Object.prototype.hasOwnProperty.call(opt, \'options\')) {\n      const {\n        label,\n        options\n      } = opt;\n      return [{\n        label\n      }, ...options];\n    }\n    return undefined;\n  }) : [];\n};\n\n// find the value object from dataOptions\nconst getSelectedObject = function (value) {\n  let dataOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (dataOptions.length > 0) {\n    if (typeof value !== \'undefined\') {\n      const flattenedOptions = flattenOptionList(dataOptions);\n      return flattenedOptions.find(o => o.value === value) || null;\n    }\n  }\n  return null;\n};\n\n/** ensureValuedOption\r\n * returns an option object that contains a \'value\' field or\r\n * recurses to the next index.\r\n */\nconst ensureValuedOption = (index, dataOptions) => {\n  if (dataOptions[index]) {\n    if (Object.prototype.hasOwnProperty.call(dataOptions[index], \'value\')) {\n      return dataOptions[index];\n    }\n    return ensureValuedOption(index + 1, dataOptions);\n  }\n  return undefined;\n};\nconst defaultItemToString = item => item?.label;\n\n// removes any option group headers, leaving only selectable options.\nconst reduceOptions = dataOptions => dataOptions?.reduce((options, op) => {\n  if (op.value) options.push(op);\n  if (op.options) return [...options, ...op.options];\n  return options;\n}, []);\n\n// reconcile index of rendered item to items that are only selectable.\nconst reconcileReducedIndex = (item, items) => {\n  return items.findIndex(i => isEqual_default()(i, item));\n};\n// EXTERNAL MODULE: ./node_modules/react-overlays/esm/Portal.js\nvar Portal = __webpack_require__("./node_modules/react-overlays/esm/Portal.js");\n// EXTERNAL MODULE: ./lib/Selection/Selection.css\nvar Selection = __webpack_require__("./lib/Selection/Selection.css");\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__("./node_modules/react/jsx-runtime.js");\n;// CONCATENATED MODULE: ./lib/Selection/SelectionList.js\n\n\n\n\nconst SelectionList = _ref => {\n  let {\n    getMenuProps,\n    labelId,\n    listMaxHeight,\n    renderOptions\n  } = _ref;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("ul", {\n    ...getMenuProps({\n      \'aria-labelledby\': labelId\n    }),\n    style: {\n      maxHeight: listMaxHeight\n    },\n    className: Selection/* default */.A.selectionList,\n    children: renderOptions()\n  });\n};\nSelectionList.displayName = "SelectionList";\nSelectionList.propTypes = {\n  getMenuProps: (prop_types_default()).func,\n  labelId: (prop_types_default()).string,\n  listMaxHeight: (prop_types_default()).string,\n  renderOptions: (prop_types_default()).func\n};\n/* harmony default export */ const Selection_SelectionList = (SelectionList);\n;\nSelectionList.__docgenInfo = {\n  "description": "",\n  "methods": [],\n  "displayName": "SelectionList",\n  "props": {\n    "getMenuProps": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "labelId": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "listMaxHeight": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "renderOptions": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    }\n  }\n};\n// EXTERNAL MODULE: ./lib/Popper/Popper.js + 1 modules\nvar Popper = __webpack_require__("./lib/Popper/Popper.js");\n;// CONCATENATED MODULE: ./lib/Selection/SelectionOverlay.js\n\n\n\n\n\n\n\nconst SelectionOverlay = _ref => {\n  let {\n    controlRef,\n    getMenuProps,\n    id,\n    isOpen,\n    listMaxHeight,\n    onChangeFilterValue,\n    optionAlignment,\n    popper,\n    renderFilterInput,\n    renderOptions,\n    usePortal,\n    width,\n    ...props\n  } = _ref;\n  const containerRef = (0,react.useRef)(null);\n  const filterRef = (0,react.useRef)(null);\n  const getPortalElement = (0,react.useRef)(() => document.getElementById(\'OverlayContainer\')).current;\n  (0,react.useEffect)(() => {\n    // if the overlay is open and focus is outside of it, move focus to the filter.\n    if (isOpen && containerRef.current?.matches(\':not(:focus-within)\')) {\n      filterRef.current?.focus();\n    }\n\n    // if overlay is closing and focus is within the overlay, move focus to the Selection control.\n    if (!isOpen && containerRef.current?.matches(\':focus-within\')) {\n      onChangeFilterValue(\'\');\n      controlRef.current?.focus();\n    }\n  }, [isOpen, onChangeFilterValue, controlRef]);\n  const atSmallMedia = window.matchMedia(\'(max-width: 640px)\').matches;\n  const selectList = /*#__PURE__*/(0,jsx_runtime.jsx)(Selection_SelectionList, {\n    renderOptions: renderOptions,\n    listMaxHeight: listMaxHeight,\n    optionAlignment: optionAlignment,\n    getMenuProps: getMenuProps,\n    ...props\n  });\n  if (atSmallMedia) {\n    return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      ref: containerRef,\n      children: isOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(Portal/* default */.A, {\n        container: getPortalElement(),\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          role: "presentation",\n          className: Selection/* default */.A.selectionMobileBackdrop,\n          onClick: () => {\n            controlRef.current?.focus();\n          },\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n            className: Selection/* default */.A.selectionListRoot,\n            style: {\n              width: \'85vw\'\n            },\n            id: `sl-container-${id}`,\n            children: [renderFilterInput(filterRef), selectList]\n          })\n        })\n      })\n    });\n  }\n  const popperProps = {\n    portal: isOpen && usePortal ? getPortalElement() : undefined,\n    modifiers: Popper/* OVERLAY_MODIFIERS */.mF,\n    ...popper\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsx)(Popper/* default */.Ay, {\n    isOpen: isOpen,\n    anchorRef: controlRef,\n    hideIfClosed: true,\n    ...popperProps,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: Selection/* default */.A.selectionListRoot,\n      style: {\n        width\n      },\n      id: `sl-container-${id}`,\n      ref: containerRef,\n      children: [renderFilterInput(filterRef), selectList]\n    })\n  });\n};\nSelectionOverlay.displayName = "SelectionOverlay";\nSelectionOverlay.propTypes = {\n  controlRef: prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).object]),\n  emptyMessage: (prop_types_default()).node,\n  getMenuProps: (prop_types_default()).func,\n  id: (prop_types_default()).string,\n  isOpen: (prop_types_default()).bool,\n  listMaxHeight: (prop_types_default()).string,\n  onChangeFilterValue: (prop_types_default()).func,\n  optionAlignment: (prop_types_default()).string,\n  popper: (prop_types_default()).object,\n  renderFilterInput: (prop_types_default()).func,\n  renderOptions: (prop_types_default()).func,\n  usePortal: (prop_types_default()).bool,\n  width: (prop_types_default()).number\n};\n/* harmony default export */ const Selection_SelectionOverlay = (SelectionOverlay);\n;\nSelectionOverlay.__docgenInfo = {\n  "description": "",\n  "methods": [],\n  "displayName": "SelectionOverlay",\n  "props": {\n    "controlRef": {\n      "description": "",\n      "type": {\n        "name": "union",\n        "value": [{\n          "name": "func"\n        }, {\n          "name": "object"\n        }]\n      },\n      "required": false\n    },\n    "emptyMessage": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    },\n    "getMenuProps": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "id": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "isOpen": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "listMaxHeight": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "onChangeFilterValue": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "optionAlignment": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "popper": {\n      "description": "",\n      "type": {\n        "name": "object"\n      },\n      "required": false\n    },\n    "renderFilterInput": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "renderOptions": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "usePortal": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "width": {\n      "description": "",\n      "type": {\n        "name": "number"\n      },\n      "required": false\n    }\n  }\n};\n// EXTERNAL MODULE: ./lib/Label/Label.js + 1 modules\nvar Label = __webpack_require__("./lib/Label/Label.js");\n// EXTERNAL MODULE: ./lib/TextField/TextFieldIcon.js\nvar TextFieldIcon = __webpack_require__("./lib/TextField/TextFieldIcon.js");\n// EXTERNAL MODULE: ./hooks/useProvidedRefOrCreate/useProvidedRefOrCreate.js\nvar useProvidedRefOrCreate = __webpack_require__("./hooks/useProvidedRefOrCreate/useProvidedRefOrCreate.js");\n// EXTERNAL MODULE: ./lib/sharedStyles/form.css\nvar sharedStyles_form = __webpack_require__("./lib/sharedStyles/form.css");\n// EXTERNAL MODULE: ./lib/Selection/DefaultOptionFormatter.js\nvar DefaultOptionFormatter = __webpack_require__("./lib/Selection/DefaultOptionFormatter.js");\n// EXTERNAL MODULE: ./hooks/useProvidedIdOrCreate/useProvidedIdOrCreate.js\nvar useProvidedIdOrCreate = __webpack_require__("./hooks/useProvidedIdOrCreate/useProvidedIdOrCreate.js");\n;// CONCATENATED MODULE: ./lib/Selection/Selection.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// a rough way to discern if an option is grouped or not - if it finds an index at the top level\n// of dataOptions, it\'s not grouped...\n\nconst optionIsGrouped = (item, dataOptions) => {\n  return dataOptions.findIndex(i => isEqual_default()(i, item)) === -1;\n};\nconst getControlWidth = control => {\n  if (control) {\n    return control.offsetWidth;\n  }\n  return undefined;\n};\nconst getItemClass = (item, i, props) => {\n  const {\n    value\n  } = item;\n  const {\n    selectedItem,\n    highlightedIndex,\n    dataOptions\n  } = props;\n  if (!value) {\n    return;\n  }\n\n  // eslint-disable-next-line consistent-return\n  return classnames_default()(Selection/* default */.A.option, {\n    [Selection/* default */.A.cursor]: i === highlightedIndex\n  }, {\n    [`${Selection/* default */.A.selected}`]: value === selectedItem?.value\n  }, {\n    [`${Selection/* default */.A.groupedOption}`]: optionIsGrouped(item, dataOptions)\n  });\n};\nconst getClass = _ref => {\n  let {\n    dirty,\n    error,\n    marginBottom0,\n    useValidStyle,\n    valid,\n    warning\n  } = _ref;\n  let validationClasses = \'\';\n  validationClasses = classnames_default()({\n    [`${sharedStyles_form/* default */.A.hasFeedback}`]: error || warning\n  }, {\n    [`${sharedStyles_form/* default */.A.hasWarning}`]: warning\n  }, {\n    [`${sharedStyles_form/* default */.A.hasError}`]: error\n  }, {\n    [`${sharedStyles_form/* default */.A.isChanged}`]: dirty\n  }, {\n    [`${sharedStyles_form/* default */.A.isValid}`]: useValidStyle && valid && !error && !warning\n  });\n  return classnames_default()(validationClasses, Selection/* default */.A.selectionControl, sharedStyles_form/* default */.A.formControl, {\n    [`${Selection/* default */.A.marginBottom0}`]: marginBottom0\n  });\n};\nconst Selection_Selection = _ref2 => {\n  let {\n    asyncFilter,\n    autofocus,\n    dataOptions,\n    dirty,\n    disabled,\n    emptyMessage,\n    error,\n    formatter = DefaultOptionFormatter/* default */.A,\n    id,\n    inputRef,\n    onBlur,\n    onChange,\n    onFocus,\n    placeholder,\n    label,\n    listMaxHeight = \'174px\',\n    loading,\n    loadingMessage,\n    marginBottom0,\n    name,\n    onFilter = filterOptionList,\n    optionAlignment,\n    popper,\n    readOnly,\n    readonly,\n    required,\n    useValidStyle = false,\n    usePortal,\n    valid,\n    value,\n    warning,\n    ...rest\n  } = _ref2;\n  const {\n    formatMessage\n  } = (0,useIntl/* default */.A)();\n  const [filterValue, updateFilterValue] = (0,react.useState)(\'\');\n  const dataLength = (0,react.useRef)(dataOptions?.length || 0);\n  const controlRef = (0,useProvidedRefOrCreate/* default */.A)(inputRef);\n  const awaitingChange = (0,react.useRef)(false);\n  const options = (0,react.useMemo)(() => asyncFilter ? dataOptions : filterValue ? onFilter(filterValue, dataOptions) : dataOptions, [asyncFilter, filterValue, dataOptions, onFilter]);\n  const testId = (0,useProvidedIdOrCreate/* default */.A)(id, \'selection-\');\n\n  // we need to skip over group headings since those can neither be selectable or cursored over.\n  const reducedListItems = reduceOptions(options);\n  const {\n    isOpen,\n    getToggleButtonProps,\n    getInputProps,\n    getLabelProps,\n    getMenuProps,\n    highlightedIndex,\n    getItemProps,\n    selectedItem,\n    selectItem: updateSelectedItem\n  } = (0,downshift_esm/* useCombobox */.Bp)({\n    items: reducedListItems,\n    itemToString: defaultItemToString,\n    initialSelectedItem: value ? getSelectedObject(value, dataOptions) : null,\n    onSelectedItemChange: _ref3 => {\n      let {\n        selectedItem: newSelectedItem\n      } = _ref3;\n      // if the newSelectedItem\'s value matches the incoming value prop, we assume that\n      // onChange isn\'t necessary.\n      if (onChange && newSelectedItem?.value !== value) {\n        onChange(newSelectedItem.value);\n      }\n    },\n    isItemDisabled(item) {\n      return (readOnly || readonly) && !isEqual_default()(item, selectedItem);\n    },\n    stateReducer(state, actionAndChanges) {\n      const {\n        changes,\n        type\n      } = actionAndChanges;\n      switch (type) {\n        case downshift_esm/* useCombobox */.Bp.stateChangeTypes.InputKeyDownEnter:\n        case downshift_esm/* useCombobox */.Bp.stateChangeTypes.ItemClick:\n          awaitingChange.current = true;\n          return changes;\n        default:\n          return changes;\n      }\n    }\n  });\n  (0,react.useEffect)(() => {\n    // if dataOptions populate/change after the initial render, update the selectedItem state\n    // if one hasn\'t been found yet.\n    if (dataOptions?.length !== dataLength.current && value && selectedItem === null) {\n      const selected = getSelectedObject(value, dataOptions);\n      updateSelectedItem(selected);\n      dataLength.current = dataOptions.length;\n    }\n  }, [dataOptions, selectedItem, value]);\n  const valueLabel = defaultItemToString(selectedItem) || placeholder || \'\';\n  const labelId = `sl-label-${testId}`;\n  const valueId = `selected-${testId}-item`;\n  if (awaitingChange.current) {\n    // a user has change the value via the dropdown and we\'re waiting for the value\n    // to correspond with the state...\n    if (selectedItem !== null && selectedItem?.value === value) {\n      awaitingChange.current = false;\n    }\n  } else if ((selectedItem !== null ||\n  // if we can find a valid dataOption to match the value (for dataOptions that have value: \'\')\n  getSelectedObject(value, dataOptions) !== null) && selectedItem?.value !== value) {\n    // conform to post-mount value prop changes from outside of the component,\n    // whether the changed value is something empty like \'\' or null;\n    const newValue = getSelectedObject(value, dataOptions) || {\n      value\n    };\n    updateSelectedItem(newValue);\n  }\n\n  /** renderOptions\r\n   *  All of the rendering of the options list is performed here.\r\n   *  This memoized function is passed into the SelectionOverlay & SelectionList\r\n   */\n\n  // It doesn\'t need to update if *all of the things it uses change...\n  /* eslint-disable react-hooks/exhaustive-deps */\n  const renderOptions = (0,react.useCallback)(() => {\n    // if options are delivered with groupings, we flatten the options for\n    // a set of selectable indices. Group labels are not selectable.\n    const flattenedOptions = flattenOptionList(options);\n    /* loading message */\n    if (loading) {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n        role: "option",\n        className: Selection/* default */.A.option,\n        "aria-selected": "false",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          children: loadingMessage\n        })\n      });\n    }\n\n    /* no options found through async filter */\n    if (dataOptions.length === 0) {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n        role: "option",\n        className: Selection/* default */.A.option,\n        "aria-selected": "false",\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n          children: ["-", emptyMessage, "-"]\n        })\n      });\n    }\n\n    /* no options found through filtering */\n    if (flattenedOptions.length === 0) {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n        role: "option",\n        className: Selection/* default */.A.option,\n        "aria-selected": "false",\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n          children: ["-", formatMessage({\n            id: \'stripes-components.selection.emptyList\'\n          }), "-"]\n        })\n      });\n    }\n    return flattenedOptions.map((item, i) => {\n      if (item.value) {\n        const reducedIndex = reconcileReducedIndex(item, reducedListItems);\n        return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n          ...getItemProps({\n            index: reducedIndex,\n            onMouseUp: e => e.stopPropagation()\n          }),\n          className: getItemClass(item, reducedIndex, {\n            selectedItem,\n            highlightedIndex,\n            dataOptions\n          }),\n          children: formatter({\n            option: item,\n            searchTerm: filterValue\n          })\n        }, `${item.label}-option-${i}`);\n      }\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n        className: Selection/* default */.A.groupLabel,\n        children: formatter({\n          option: item,\n          searchTerm: filterValue\n        })\n      }, `${item.label}-heading-${i}`);\n    });\n  }, [loading, filterValue, selectedItem, highlightedIndex, value, options]);\n  const renderFilterInput = (0,react.useCallback)(filterRef => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: Selection/* default */.A.selectionFilterContainer,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n      type: "text",\n      ...getInputProps({\n        ref: filterRef,\n        value: filterValue,\n        // stopPropagation to keep from unwantedly triggering shortcuts and\n        // address downshift issues with portal rendering/functionality.\n        // https://github.com/downshift-js/downshift/issues/287\n        onKeyDown: e => e.stopPropagation(),\n        onMouseUp: e => e.stopPropagation()\n      }),\n      onClick: () => {},\n      onChange: e => updateFilterValue(e.target.value),\n      "aria-label": formatMessage({\n        id: \'stripes-components.selection.filterOptionsLabel\'\n      }, {\n        label\n      }),\n      className: Selection/* default */.A.selectionFilter,\n      placeholder: formatMessage({\n        id: \'stripes-components.selection.filterOptionsPlaceholder\'\n      })\n    })\n  }), [filterValue]);\n  const getControlClass = (0,react.useMemo)(() => getClass({\n    dirty,\n    error,\n    marginBottom0,\n    useValidStyle,\n    valid,\n    warning\n  }), [error, warning, dirty, valid, useValidStyle, marginBottom0]);\n\n  /* eslint-enable react-hooks/exhaustive-deps */\n\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n    children: [label && /*#__PURE__*/(0,jsx_runtime.jsx)(Label/* default */.A, {\n      ...getLabelProps({\n        id: labelId\n      }),\n      readOnly: readOnly || readonly,\n      required: required,\n      children: label\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: Selection/* default */.A.selectionControlContainer,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("button", {\n        type: "button",\n        ...getToggleButtonProps({\n          ref: controlRef,\n          tabIndex: undefined,\n          disabled,\n          readOnly,\n          id: testId,\n          \'aria-labelledby\': `${labelId} ${valueId}`\n        }),\n        className: getControlClass,\n        autoFocus: autofocus,\n        onBlur: onBlur,\n        onFocus: onFocus,\n        name: name,\n        value: selectedItem?.value,\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n          className: "sr-only",\n          children: formatMessage({\n            id: \'stripes-components.selection.controlLabel\'\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: Selection/* default */.A.singleValue,\n          id: valueId,\n          children: valueLabel\n        })]\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: Selection/* default */.A.selectionEndControls,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(TextFieldIcon/* default */.A, {\n          icon: "triangle-down"\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        role: "alert",\n        children: [warning && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: `${sharedStyles_form/* default */.A.feedbackWarning}`,\n          children: warning\n        }), error && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: `${sharedStyles_form/* default */.A.feedbackError}`,\n          children: error\n        })]\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Selection_SelectionOverlay, {\n      ...rest,\n      controlRef: controlRef,\n      getMenuProps: getMenuProps,\n      id: testId,\n      isOpen: isOpen,\n      listMaxHeight: listMaxHeight,\n      onChangeFilterValue: updateFilterValue,\n      optionAlignment: optionAlignment,\n      popper: popper,\n      renderFilterInput: renderFilterInput,\n      renderOptions: renderOptions,\n      usePortal: usePortal,\n      width: getControlWidth(controlRef.current),\n      labelId: labelId\n    })]\n  });\n};\nSelection_Selection.displayName = "Selection";\nSelection_Selection.propTypes = {\n  asyncFilter: (prop_types_default()).func,\n  autofocus: (prop_types_default()).bool,\n  dataOptions: prop_types_default().arrayOf((prop_types_default()).object),\n  dirty: (prop_types_default()).bool,\n  disabled: (prop_types_default()).bool,\n  emptyMessage: (prop_types_default()).node,\n  error: (prop_types_default()).node,\n  formatter: (prop_types_default()).func,\n  id: (prop_types_default()).string,\n  inputRef: prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).func]),\n  label: (prop_types_default()).node,\n  listMaxHeight: (prop_types_default()).string,\n  loading: (prop_types_default()).bool,\n  loadingMessage: (prop_types_default()).node,\n  marginBottom0: (prop_types_default()).bool,\n  name: (prop_types_default()).string,\n  onBlur: (prop_types_default()).func,\n  onChange: (prop_types_default()).func,\n  onFilter: (prop_types_default()).func,\n  onFocus: (prop_types_default()).func,\n  optionAlignment: (prop_types_default()).string,\n  placeholder: (prop_types_default()).node,\n  popper: prop_types_default().shape({\n    portal: (0,lib/* deprecated */.io)((prop_types_default()).element, \'use the boolean usePortal prop of Selection instead\')\n  }),\n  readOnly: (prop_types_default()).bool,\n  readonly: (prop_types_default()).bool,\n  required: (prop_types_default()).bool,\n  usePortal: (prop_types_default()).bool,\n  useValidStyle: (prop_types_default()).bool,\n  valid: (prop_types_default()).bool,\n  value: (prop_types_default()).string,\n  warning: (prop_types_default()).node\n};\n/* harmony default export */ const lib_Selection_Selection = ((0,FormField/* default */.A)(Selection_Selection, _ref4 => {\n  let {\n    meta\n  } = _ref4;\n  return {\n    dirty: meta.dirty,\n    error: meta.touched && meta.error ? meta.error : \'\',\n    valid: meta.valid,\n    warning: meta.touched ? (0,parseMeta/* default */.A)(meta, \'warning\') : \'\'\n  };\n}));\n;\nSelection_Selection.__docgenInfo = {\n  "description": "",\n  "methods": [],\n  "displayName": "Selection",\n  "props": {\n    "formatter": {\n      "defaultValue": {\n        "value": "({ option, searchTerm }) => {\\r\\n  return option ?\\r\\n    <OptionSegment searchTerm={searchTerm}>{option.label}</OptionSegment> :\\r\\n    null;\\r\\n}",\n        "computed": false\n      },\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "listMaxHeight": {\n      "defaultValue": {\n        "value": "\'174px\'",\n        "computed": false\n      },\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "onFilter": {\n      "defaultValue": {\n        "value": "(value, dataOptions) => {\\r\\n  const valueRE = new RegExp(`^${value}`, \'i\');\\r\\n  const baseFilter = (o) => valueRE.test(o.label);\\r\\n  // if items have an \'options\' field, filter those items and return the dataOptions group with the\\r\\n  // results inserted.\\r\\n  const grouped = dataOptions.some((o) => Object.prototype.hasOwnProperty.call(o, \'options\'));\\r\\n  if (grouped) {\\r\\n    return dataOptions.reduce((options, opt) => {\\r\\n      // global, ungrouped options\\r\\n      if (Object.prototype.hasOwnProperty.call(opt, \'value\')) {\\r\\n        if (valueRE.test(opt.label)) {\\r\\n          return [...options, opt];\\r\\n        }\\r\\n      } else if (Object.prototype.hasOwnProperty.call(opt, \'options\')) {\\r\\n        const filteredOptions = opt.options.filter(baseFilter);\\r\\n        if (filteredOptions.length > 0) {\\r\\n          return [...options, { ...opt, options: filteredOptions }];\\r\\n        }\\r\\n      }\\r\\n      return options;\\r\\n    }, []);\\r\\n  }\\r\\n  return dataOptions.filter(baseFilter);\\r\\n}",\n        "computed": false\n      },\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "useValidStyle": {\n      "defaultValue": {\n        "value": "false",\n        "computed": false\n      },\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "asyncFilter": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "autofocus": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "dataOptions": {\n      "description": "",\n      "type": {\n        "name": "arrayOf",\n        "value": {\n          "name": "object"\n        }\n      },\n      "required": false\n    },\n    "dirty": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "disabled": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "emptyMessage": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    },\n    "error": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    },\n    "id": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "inputRef": {\n      "description": "",\n      "type": {\n        "name": "union",\n        "value": [{\n          "name": "object"\n        }, {\n          "name": "func"\n        }]\n      },\n      "required": false\n    },\n    "label": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    },\n    "loading": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "loadingMessage": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    },\n    "marginBottom0": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "name": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "onBlur": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "onChange": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "onFocus": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "optionAlignment": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "placeholder": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    },\n    "popper": {\n      "description": "",\n      "type": {\n        "name": "shape",\n        "value": {\n          "portal": {\n            "name": "custom",\n            "raw": "deprecated(PropTypes.element, \'use the boolean usePortal prop of Selection instead\')",\n            "required": false\n          }\n        }\n      },\n      "required": false\n    },\n    "readOnly": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "readonly": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "required": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "usePortal": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "valid": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "value": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "warning": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvU2VsZWN0aW9uL1NlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi9saWIvU2VsZWN0aW9uL3V0aWxzLmpzP2QwMGUiLCJ3ZWJwYWNrOi8vQGZvbGlvL3N0cmlwZXMtY29tcG9uZW50cy8uL2xpYi9TZWxlY3Rpb24vU2VsZWN0aW9uTGlzdC5qcz9jYmZlIiwid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi9saWIvU2VsZWN0aW9uL1NlbGVjdGlvbk92ZXJsYXkuanM/ZWNjMCIsIndlYnBhY2s6Ly9AZm9saW8vc3RyaXBlcy1jb21wb25lbnRzLy4vbGliL1NlbGVjdGlvbi9TZWxlY3Rpb24uanM/NjFhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5cbi8qIGZpbHRlck9wdGlvbkxpc3RcclxuICogICBjb25mb3JtcyB0byBzaGFwZXMgb2Ygb3B0aW9ucy5cclxuICogICBzdGFuZGFyZCBvcHRpb25zIGFyZSB7IHZhbHVlLCBsYWJlbCB9XHJcbiAqICAgZ3JvdXBlZCBvcHRpb25zIGFyZSB7IGxhYmVsLCBvcHRpb25zIH0gd2hlcmUgb3B0aW9ucyBjb250YWlucyBzdGFuZGFyZCBvcHRpb25zLlxyXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXJPcHRpb25MaXN0ID0gKHZhbHVlLCBkYXRhT3B0aW9ucykgPT4ge1xuICBjb25zdCB2YWx1ZVJFID0gbmV3IFJlZ0V4cChgXiR7dmFsdWV9YCwgJ2knKTtcbiAgY29uc3QgYmFzZUZpbHRlciA9IG8gPT4gdmFsdWVSRS50ZXN0KG8ubGFiZWwpO1xuICAvLyBpZiBpdGVtcyBoYXZlIGFuICdvcHRpb25zJyBmaWVsZCwgZmlsdGVyIHRob3NlIGl0ZW1zIGFuZCByZXR1cm4gdGhlIGRhdGFPcHRpb25zIGdyb3VwIHdpdGggdGhlXG4gIC8vIHJlc3VsdHMgaW5zZXJ0ZWQuXG4gIGNvbnN0IGdyb3VwZWQgPSBkYXRhT3B0aW9ucy5zb21lKG8gPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sICdvcHRpb25zJykpO1xuICBpZiAoZ3JvdXBlZCkge1xuICAgIHJldHVybiBkYXRhT3B0aW9ucy5yZWR1Y2UoKG9wdGlvbnMsIG9wdCkgPT4ge1xuICAgICAgLy8gZ2xvYmFsLCB1bmdyb3VwZWQgb3B0aW9uc1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHQsICd2YWx1ZScpKSB7XG4gICAgICAgIGlmICh2YWx1ZVJFLnRlc3Qob3B0LmxhYmVsKSkge1xuICAgICAgICAgIHJldHVybiBbLi4ub3B0aW9ucywgb3B0XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0LCAnb3B0aW9ucycpKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkT3B0aW9ucyA9IG9wdC5vcHRpb25zLmZpbHRlcihiYXNlRmlsdGVyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5vcHRpb25zLCB7XG4gICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICBvcHRpb25zOiBmaWx0ZXJlZE9wdGlvbnNcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSwgW10pO1xuICB9XG4gIHJldHVybiBkYXRhT3B0aW9ucy5maWx0ZXIoYmFzZUZpbHRlcik7XG59O1xuZXhwb3J0IGNvbnN0IGZsYXR0ZW5PcHRpb25MaXN0ID0gZGF0YU9wdGlvbnMgPT4ge1xuICByZXR1cm4gZGF0YU9wdGlvbnMgPyBkYXRhT3B0aW9ucy5mbGF0TWFwKG9wdCA9PiB7XG4gICAgLy8gZ2xvYmFsLCB1bmdyb3VwZWQgb3B0aW9uc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0LCAndmFsdWUnKSkge1xuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHQsICdvcHRpb25zJykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSBvcHQ7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgbGFiZWxcbiAgICAgIH0sIC4uLm9wdGlvbnNdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9KSA6IFtdO1xufTtcblxuLy8gZmluZCB0aGUgdmFsdWUgb2JqZWN0IGZyb20gZGF0YU9wdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRTZWxlY3RlZE9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBsZXQgZGF0YU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICBpZiAoZGF0YU9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBmbGF0dGVuZWRPcHRpb25zID0gZmxhdHRlbk9wdGlvbkxpc3QoZGF0YU9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZsYXR0ZW5lZE9wdGlvbnMuZmluZChvID0+IG8udmFsdWUgPT09IHZhbHVlKSB8fCBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKiBlbnN1cmVWYWx1ZWRPcHRpb25cclxuICogcmV0dXJucyBhbiBvcHRpb24gb2JqZWN0IHRoYXQgY29udGFpbnMgYSAndmFsdWUnIGZpZWxkIG9yXHJcbiAqIHJlY3Vyc2VzIHRvIHRoZSBuZXh0IGluZGV4LlxyXG4gKi9cbmV4cG9ydCBjb25zdCBlbnN1cmVWYWx1ZWRPcHRpb24gPSAoaW5kZXgsIGRhdGFPcHRpb25zKSA9PiB7XG4gIGlmIChkYXRhT3B0aW9uc1tpbmRleF0pIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFPcHRpb25zW2luZGV4XSwgJ3ZhbHVlJykpIHtcbiAgICAgIHJldHVybiBkYXRhT3B0aW9uc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBlbnN1cmVWYWx1ZWRPcHRpb24oaW5kZXggKyAxLCBkYXRhT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5leHBvcnQgY29uc3QgZGVmYXVsdEl0ZW1Ub1N0cmluZyA9IGl0ZW0gPT4gaXRlbT8ubGFiZWw7XG5cbi8vIHJlbW92ZXMgYW55IG9wdGlvbiBncm91cCBoZWFkZXJzLCBsZWF2aW5nIG9ubHkgc2VsZWN0YWJsZSBvcHRpb25zLlxuZXhwb3J0IGNvbnN0IHJlZHVjZU9wdGlvbnMgPSBkYXRhT3B0aW9ucyA9PiBkYXRhT3B0aW9ucz8ucmVkdWNlKChvcHRpb25zLCBvcCkgPT4ge1xuICBpZiAob3AudmFsdWUpIG9wdGlvbnMucHVzaChvcCk7XG4gIGlmIChvcC5vcHRpb25zKSByZXR1cm4gWy4uLm9wdGlvbnMsIC4uLm9wLm9wdGlvbnNdO1xuICByZXR1cm4gb3B0aW9ucztcbn0sIFtdKTtcblxuLy8gcmVjb25jaWxlIGluZGV4IG9mIHJlbmRlcmVkIGl0ZW0gdG8gaXRlbXMgdGhhdCBhcmUgb25seSBzZWxlY3RhYmxlLlxuZXhwb3J0IGNvbnN0IHJlY29uY2lsZVJlZHVjZWRJbmRleCA9IChpdGVtLCBpdGVtcykgPT4ge1xuICByZXR1cm4gaXRlbXMuZmluZEluZGV4KGkgPT4gaXNFcXVhbChpLCBpdGVtKSk7XG59OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNzcyBmcm9tICcuL1NlbGVjdGlvbi5jc3MnO1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmNvbnN0IFNlbGVjdGlvbkxpc3QgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBnZXRNZW51UHJvcHMsXG4gICAgbGFiZWxJZCxcbiAgICBsaXN0TWF4SGVpZ2h0LFxuICAgIHJlbmRlck9wdGlvbnNcbiAgfSA9IF9yZWY7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChcInVsXCIsIHtcbiAgICAuLi5nZXRNZW51UHJvcHMoe1xuICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxhYmVsSWRcbiAgICB9KSxcbiAgICBzdHlsZToge1xuICAgICAgbWF4SGVpZ2h0OiBsaXN0TWF4SGVpZ2h0XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IGNzcy5zZWxlY3Rpb25MaXN0LFxuICAgIGNoaWxkcmVuOiByZW5kZXJPcHRpb25zKClcbiAgfSk7XG59O1xuU2VsZWN0aW9uTGlzdC5kaXNwbGF5TmFtZSA9IFwiU2VsZWN0aW9uTGlzdFwiO1xuU2VsZWN0aW9uTGlzdC5wcm9wVHlwZXMgPSB7XG4gIGdldE1lbnVQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIGxhYmVsSWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxpc3RNYXhIZWlnaHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHJlbmRlck9wdGlvbnM6IFByb3BUeXBlcy5mdW5jXG59O1xuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uTGlzdDtcbjtcblNlbGVjdGlvbkxpc3QuX19kb2NnZW5JbmZvID0ge1xuICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gIFwibWV0aG9kc1wiOiBbXSxcbiAgXCJkaXNwbGF5TmFtZVwiOiBcIlNlbGVjdGlvbkxpc3RcIixcbiAgXCJwcm9wc1wiOiB7XG4gICAgXCJnZXRNZW51UHJvcHNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZnVuY1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJsYWJlbElkXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJsaXN0TWF4SGVpZ2h0XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJyZW5kZXJPcHRpb25zXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImZ1bmNcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG4gIH1cbn07IiwiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBQb3J0YWwgZnJvbSAncmVhY3Qtb3ZlcmxheXMvUG9ydGFsJztcbmltcG9ydCBTZWxlY3Rpb25MaXN0IGZyb20gJy4vU2VsZWN0aW9uTGlzdCc7XG5pbXBvcnQgUG9wcGVyLCB7IE9WRVJMQVlfTU9ESUZJRVJTIH0gZnJvbSAnLi4vUG9wcGVyJztcbmltcG9ydCBjc3MgZnJvbSAnLi9TZWxlY3Rpb24uY3NzJztcbmltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBTZWxlY3Rpb25PdmVybGF5ID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY29udHJvbFJlZixcbiAgICBnZXRNZW51UHJvcHMsXG4gICAgaWQsXG4gICAgaXNPcGVuLFxuICAgIGxpc3RNYXhIZWlnaHQsXG4gICAgb25DaGFuZ2VGaWx0ZXJWYWx1ZSxcbiAgICBvcHRpb25BbGlnbm1lbnQsXG4gICAgcG9wcGVyLFxuICAgIHJlbmRlckZpbHRlcklucHV0LFxuICAgIHJlbmRlck9wdGlvbnMsXG4gICAgdXNlUG9ydGFsLFxuICAgIHdpZHRoLFxuICAgIC4uLnByb3BzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZpbHRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZ2V0UG9ydGFsRWxlbWVudCA9IHVzZVJlZigoKSA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnT3ZlcmxheUNvbnRhaW5lcicpKS5jdXJyZW50O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIGlmIHRoZSBvdmVybGF5IGlzIG9wZW4gYW5kIGZvY3VzIGlzIG91dHNpZGUgb2YgaXQsIG1vdmUgZm9jdXMgdG8gdGhlIGZpbHRlci5cbiAgICBpZiAoaXNPcGVuICYmIGNvbnRhaW5lclJlZi5jdXJyZW50Py5tYXRjaGVzKCc6bm90KDpmb2N1cy13aXRoaW4pJykpIHtcbiAgICAgIGZpbHRlclJlZi5jdXJyZW50Py5mb2N1cygpO1xuICAgIH1cblxuICAgIC8vIGlmIG92ZXJsYXkgaXMgY2xvc2luZyBhbmQgZm9jdXMgaXMgd2l0aGluIHRoZSBvdmVybGF5LCBtb3ZlIGZvY3VzIHRvIHRoZSBTZWxlY3Rpb24gY29udHJvbC5cbiAgICBpZiAoIWlzT3BlbiAmJiBjb250YWluZXJSZWYuY3VycmVudD8ubWF0Y2hlcygnOmZvY3VzLXdpdGhpbicpKSB7XG4gICAgICBvbkNoYW5nZUZpbHRlclZhbHVlKCcnKTtcbiAgICAgIGNvbnRyb2xSZWYuY3VycmVudD8uZm9jdXMoKTtcbiAgICB9XG4gIH0sIFtpc09wZW4sIG9uQ2hhbmdlRmlsdGVyVmFsdWUsIGNvbnRyb2xSZWZdKTtcbiAgY29uc3QgYXRTbWFsbE1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtYXgtd2lkdGg6IDY0MHB4KScpLm1hdGNoZXM7XG4gIGNvbnN0IHNlbGVjdExpc3QgPSAvKiNfX1BVUkVfXyovX2pzeChTZWxlY3Rpb25MaXN0LCB7XG4gICAgcmVuZGVyT3B0aW9uczogcmVuZGVyT3B0aW9ucyxcbiAgICBsaXN0TWF4SGVpZ2h0OiBsaXN0TWF4SGVpZ2h0LFxuICAgIG9wdGlvbkFsaWdubWVudDogb3B0aW9uQWxpZ25tZW50LFxuICAgIGdldE1lbnVQcm9wczogZ2V0TWVudVByb3BzLFxuICAgIC4uLnByb3BzXG4gIH0pO1xuICBpZiAoYXRTbWFsbE1lZGlhKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgY2hpbGRyZW46IGlzT3BlbiAmJiAvKiNfX1BVUkVfXyovX2pzeChQb3J0YWwsIHtcbiAgICAgICAgY29udGFpbmVyOiBnZXRQb3J0YWxFbGVtZW50KCksXG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChcImRpdlwiLCB7XG4gICAgICAgICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICAgICAgICBjbGFzc05hbWU6IGNzcy5zZWxlY3Rpb25Nb2JpbGVCYWNrZHJvcCxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL19qc3hzKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY3NzLnNlbGVjdGlvbkxpc3RSb290LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6ICc4NXZ3J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiBgc2wtY29udGFpbmVyLSR7aWR9YCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbcmVuZGVyRmlsdGVySW5wdXQoZmlsdGVyUmVmKSwgc2VsZWN0TGlzdF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwb3BwZXJQcm9wcyA9IHtcbiAgICBwb3J0YWw6IGlzT3BlbiAmJiB1c2VQb3J0YWwgPyBnZXRQb3J0YWxFbGVtZW50KCkgOiB1bmRlZmluZWQsXG4gICAgbW9kaWZpZXJzOiBPVkVSTEFZX01PRElGSUVSUyxcbiAgICAuLi5wb3BwZXJcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KFBvcHBlciwge1xuICAgIGlzT3BlbjogaXNPcGVuLFxuICAgIGFuY2hvclJlZjogY29udHJvbFJlZixcbiAgICBoaWRlSWZDbG9zZWQ6IHRydWUsXG4gICAgLi4ucG9wcGVyUHJvcHMsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9fanN4cyhcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IGNzcy5zZWxlY3Rpb25MaXN0Um9vdCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoXG4gICAgICB9LFxuICAgICAgaWQ6IGBzbC1jb250YWluZXItJHtpZH1gLFxuICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICBjaGlsZHJlbjogW3JlbmRlckZpbHRlcklucHV0KGZpbHRlclJlZiksIHNlbGVjdExpc3RdXG4gICAgfSlcbiAgfSk7XG59O1xuU2VsZWN0aW9uT3ZlcmxheS5kaXNwbGF5TmFtZSA9IFwiU2VsZWN0aW9uT3ZlcmxheVwiO1xuU2VsZWN0aW9uT3ZlcmxheS5wcm9wVHlwZXMgPSB7XG4gIGNvbnRyb2xSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIGVtcHR5TWVzc2FnZTogUHJvcFR5cGVzLm5vZGUsXG4gIGdldE1lbnVQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBpc09wZW46IFByb3BUeXBlcy5ib29sLFxuICBsaXN0TWF4SGVpZ2h0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvbkNoYW5nZUZpbHRlclZhbHVlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb3B0aW9uQWxpZ25tZW50OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBwb3BwZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gIHJlbmRlckZpbHRlcklucHV0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcmVuZGVyT3B0aW9uczogUHJvcFR5cGVzLmZ1bmMsXG4gIHVzZVBvcnRhbDogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyXG59O1xuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uT3ZlcmxheTtcbjtcblNlbGVjdGlvbk92ZXJsYXkuX19kb2NnZW5JbmZvID0ge1xuICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gIFwibWV0aG9kc1wiOiBbXSxcbiAgXCJkaXNwbGF5TmFtZVwiOiBcIlNlbGVjdGlvbk92ZXJsYXlcIixcbiAgXCJwcm9wc1wiOiB7XG4gICAgXCJjb250cm9sUmVmXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInVuaW9uXCIsXG4gICAgICAgIFwidmFsdWVcIjogW3tcbiAgICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIFwibmFtZVwiOiBcIm9iamVjdFwiXG4gICAgICAgIH1dXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJlbXB0eU1lc3NhZ2VcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJnZXRNZW51UHJvcHNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZnVuY1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJpZFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiaXNPcGVuXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwibGlzdE1heEhlaWdodFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwib25DaGFuZ2VGaWx0ZXJWYWx1ZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcIm9wdGlvbkFsaWdubWVudFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwicG9wcGVyXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcIm9iamVjdFwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJyZW5kZXJGaWx0ZXJJbnB1dFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInJlbmRlck9wdGlvbnNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZnVuY1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJ1c2VQb3J0YWxcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9vbFwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJ3aWR0aFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG4gIH1cbn07IiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZGVwcmVjYXRlZCB9IGZyb20gJ3Byb3AtdHlwZXMtZXh0cmEnO1xuaW1wb3J0IHsgdXNlSW50bCB9IGZyb20gJ3JlYWN0LWludGwnO1xuaW1wb3J0IHsgdXNlQ29tYm9ib3ggfSBmcm9tICdkb3duc2hpZnQnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5pbXBvcnQgZm9ybUZpZWxkIGZyb20gJy4uL0Zvcm1GaWVsZCc7XG5pbXBvcnQgcGFyc2VNZXRhIGZyb20gJy4uL0Zvcm1GaWVsZC9wYXJzZU1ldGEnO1xuaW1wb3J0IHsgZGVmYXVsdEl0ZW1Ub1N0cmluZywgcmVkdWNlT3B0aW9ucywgZmlsdGVyT3B0aW9uTGlzdCwgZ2V0U2VsZWN0ZWRPYmplY3QsIGZsYXR0ZW5PcHRpb25MaXN0LCByZWNvbmNpbGVSZWR1Y2VkSW5kZXggfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBTZWxlY3Rpb25PdmVybGF5IGZyb20gJy4vU2VsZWN0aW9uT3ZlcmxheSc7XG5pbXBvcnQgTGFiZWwgZnJvbSAnLi4vTGFiZWwnO1xuaW1wb3J0IFRleHRGaWVsZEljb24gZnJvbSAnLi4vVGV4dEZpZWxkL1RleHRGaWVsZEljb24nO1xuaW1wb3J0IHVzZVByb3ZpZGVkUmVmT3JDcmVhdGUgZnJvbSAnLi4vLi4vaG9va3MvdXNlUHJvdmlkZWRSZWZPckNyZWF0ZSc7XG5pbXBvcnQgZm9ybVN0eWxlcyBmcm9tICcuLi9zaGFyZWRTdHlsZXMvZm9ybS5jc3MnO1xuaW1wb3J0IGNzcyBmcm9tICcuL1NlbGVjdGlvbi5jc3MnO1xuaW1wb3J0IERlZmF1bHRPcHRpb25Gb3JtYXR0ZXIgZnJvbSAnLi9EZWZhdWx0T3B0aW9uRm9ybWF0dGVyJztcbmltcG9ydCB1c2VQcm92aWRlZElkT3JDcmVhdGUgZnJvbSAnLi4vLi4vaG9va3MvdXNlUHJvdmlkZWRJZE9yQ3JlYXRlJztcblxuLy8gYSByb3VnaCB3YXkgdG8gZGlzY2VybiBpZiBhbiBvcHRpb24gaXMgZ3JvdXBlZCBvciBub3QgLSBpZiBpdCBmaW5kcyBhbiBpbmRleCBhdCB0aGUgdG9wIGxldmVsXG4vLyBvZiBkYXRhT3B0aW9ucywgaXQncyBub3QgZ3JvdXBlZC4uLlxuaW1wb3J0IHsganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmNvbnN0IG9wdGlvbklzR3JvdXBlZCA9IChpdGVtLCBkYXRhT3B0aW9ucykgPT4ge1xuICByZXR1cm4gZGF0YU9wdGlvbnMuZmluZEluZGV4KGkgPT4gaXNFcXVhbChpLCBpdGVtKSkgPT09IC0xO1xufTtcbmNvbnN0IGdldENvbnRyb2xXaWR0aCA9IGNvbnRyb2wgPT4ge1xuICBpZiAoY29udHJvbCkge1xuICAgIHJldHVybiBjb250cm9sLm9mZnNldFdpZHRoO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgZ2V0SXRlbUNsYXNzID0gKGl0ZW0sIGksIHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZVxuICB9ID0gaXRlbTtcbiAgY29uc3Qge1xuICAgIHNlbGVjdGVkSXRlbSxcbiAgICBoaWdobGlnaHRlZEluZGV4LFxuICAgIGRhdGFPcHRpb25zXG4gIH0gPSBwcm9wcztcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICByZXR1cm4gY2xhc3NOYW1lcyhjc3Mub3B0aW9uLCB7XG4gICAgW2Nzcy5jdXJzb3JdOiBpID09PSBoaWdobGlnaHRlZEluZGV4XG4gIH0sIHtcbiAgICBbYCR7Y3NzLnNlbGVjdGVkfWBdOiB2YWx1ZSA9PT0gc2VsZWN0ZWRJdGVtPy52YWx1ZVxuICB9LCB7XG4gICAgW2Ake2Nzcy5ncm91cGVkT3B0aW9ufWBdOiBvcHRpb25Jc0dyb3VwZWQoaXRlbSwgZGF0YU9wdGlvbnMpXG4gIH0pO1xufTtcbmNvbnN0IGdldENsYXNzID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZGlydHksXG4gICAgZXJyb3IsXG4gICAgbWFyZ2luQm90dG9tMCxcbiAgICB1c2VWYWxpZFN0eWxlLFxuICAgIHZhbGlkLFxuICAgIHdhcm5pbmdcbiAgfSA9IF9yZWY7XG4gIGxldCB2YWxpZGF0aW9uQ2xhc3NlcyA9ICcnO1xuICB2YWxpZGF0aW9uQ2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgIFtgJHtmb3JtU3R5bGVzLmhhc0ZlZWRiYWNrfWBdOiBlcnJvciB8fCB3YXJuaW5nXG4gIH0sIHtcbiAgICBbYCR7Zm9ybVN0eWxlcy5oYXNXYXJuaW5nfWBdOiB3YXJuaW5nXG4gIH0sIHtcbiAgICBbYCR7Zm9ybVN0eWxlcy5oYXNFcnJvcn1gXTogZXJyb3JcbiAgfSwge1xuICAgIFtgJHtmb3JtU3R5bGVzLmlzQ2hhbmdlZH1gXTogZGlydHlcbiAgfSwge1xuICAgIFtgJHtmb3JtU3R5bGVzLmlzVmFsaWR9YF06IHVzZVZhbGlkU3R5bGUgJiYgdmFsaWQgJiYgIWVycm9yICYmICF3YXJuaW5nXG4gIH0pO1xuICByZXR1cm4gY2xhc3NOYW1lcyh2YWxpZGF0aW9uQ2xhc3NlcywgY3NzLnNlbGVjdGlvbkNvbnRyb2wsIGZvcm1TdHlsZXMuZm9ybUNvbnRyb2wsIHtcbiAgICBbYCR7Y3NzLm1hcmdpbkJvdHRvbTB9YF06IG1hcmdpbkJvdHRvbTBcbiAgfSk7XG59O1xuY29uc3QgU2VsZWN0aW9uID0gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIGFzeW5jRmlsdGVyLFxuICAgIGF1dG9mb2N1cyxcbiAgICBkYXRhT3B0aW9ucyxcbiAgICBkaXJ0eSxcbiAgICBkaXNhYmxlZCxcbiAgICBlbXB0eU1lc3NhZ2UsXG4gICAgZXJyb3IsXG4gICAgZm9ybWF0dGVyID0gRGVmYXVsdE9wdGlvbkZvcm1hdHRlcixcbiAgICBpZCxcbiAgICBpbnB1dFJlZixcbiAgICBvbkJsdXIsXG4gICAgb25DaGFuZ2UsXG4gICAgb25Gb2N1cyxcbiAgICBwbGFjZWhvbGRlcixcbiAgICBsYWJlbCxcbiAgICBsaXN0TWF4SGVpZ2h0ID0gJzE3NHB4JyxcbiAgICBsb2FkaW5nLFxuICAgIGxvYWRpbmdNZXNzYWdlLFxuICAgIG1hcmdpbkJvdHRvbTAsXG4gICAgbmFtZSxcbiAgICBvbkZpbHRlciA9IGZpbHRlck9wdGlvbkxpc3QsXG4gICAgb3B0aW9uQWxpZ25tZW50LFxuICAgIHBvcHBlcixcbiAgICByZWFkT25seSxcbiAgICByZWFkb25seSxcbiAgICByZXF1aXJlZCxcbiAgICB1c2VWYWxpZFN0eWxlID0gZmFsc2UsXG4gICAgdXNlUG9ydGFsLFxuICAgIHZhbGlkLFxuICAgIHZhbHVlLFxuICAgIHdhcm5pbmcsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHtcbiAgICBmb3JtYXRNZXNzYWdlXG4gIH0gPSB1c2VJbnRsKCk7XG4gIGNvbnN0IFtmaWx0ZXJWYWx1ZSwgdXBkYXRlRmlsdGVyVmFsdWVdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBkYXRhTGVuZ3RoID0gdXNlUmVmKGRhdGFPcHRpb25zPy5sZW5ndGggfHwgMCk7XG4gIGNvbnN0IGNvbnRyb2xSZWYgPSB1c2VQcm92aWRlZFJlZk9yQ3JlYXRlKGlucHV0UmVmKTtcbiAgY29uc3QgYXdhaXRpbmdDaGFuZ2UgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBvcHRpb25zID0gdXNlTWVtbygoKSA9PiBhc3luY0ZpbHRlciA/IGRhdGFPcHRpb25zIDogZmlsdGVyVmFsdWUgPyBvbkZpbHRlcihmaWx0ZXJWYWx1ZSwgZGF0YU9wdGlvbnMpIDogZGF0YU9wdGlvbnMsIFthc3luY0ZpbHRlciwgZmlsdGVyVmFsdWUsIGRhdGFPcHRpb25zLCBvbkZpbHRlcl0pO1xuICBjb25zdCB0ZXN0SWQgPSB1c2VQcm92aWRlZElkT3JDcmVhdGUoaWQsICdzZWxlY3Rpb24tJyk7XG5cbiAgLy8gd2UgbmVlZCB0byBza2lwIG92ZXIgZ3JvdXAgaGVhZGluZ3Mgc2luY2UgdGhvc2UgY2FuIG5laXRoZXIgYmUgc2VsZWN0YWJsZSBvciBjdXJzb3JlZCBvdmVyLlxuICBjb25zdCByZWR1Y2VkTGlzdEl0ZW1zID0gcmVkdWNlT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3Qge1xuICAgIGlzT3BlbixcbiAgICBnZXRUb2dnbGVCdXR0b25Qcm9wcyxcbiAgICBnZXRJbnB1dFByb3BzLFxuICAgIGdldExhYmVsUHJvcHMsXG4gICAgZ2V0TWVudVByb3BzLFxuICAgIGhpZ2hsaWdodGVkSW5kZXgsXG4gICAgZ2V0SXRlbVByb3BzLFxuICAgIHNlbGVjdGVkSXRlbSxcbiAgICBzZWxlY3RJdGVtOiB1cGRhdGVTZWxlY3RlZEl0ZW1cbiAgfSA9IHVzZUNvbWJvYm94KHtcbiAgICBpdGVtczogcmVkdWNlZExpc3RJdGVtcyxcbiAgICBpdGVtVG9TdHJpbmc6IGRlZmF1bHRJdGVtVG9TdHJpbmcsXG4gICAgaW5pdGlhbFNlbGVjdGVkSXRlbTogdmFsdWUgPyBnZXRTZWxlY3RlZE9iamVjdCh2YWx1ZSwgZGF0YU9wdGlvbnMpIDogbnVsbCxcbiAgICBvblNlbGVjdGVkSXRlbUNoYW5nZTogX3JlZjMgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgc2VsZWN0ZWRJdGVtOiBuZXdTZWxlY3RlZEl0ZW1cbiAgICAgIH0gPSBfcmVmMztcbiAgICAgIC8vIGlmIHRoZSBuZXdTZWxlY3RlZEl0ZW0ncyB2YWx1ZSBtYXRjaGVzIHRoZSBpbmNvbWluZyB2YWx1ZSBwcm9wLCB3ZSBhc3N1bWUgdGhhdFxuICAgICAgLy8gb25DaGFuZ2UgaXNuJ3QgbmVjZXNzYXJ5LlxuICAgICAgaWYgKG9uQ2hhbmdlICYmIG5ld1NlbGVjdGVkSXRlbT8udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIG9uQ2hhbmdlKG5ld1NlbGVjdGVkSXRlbS52YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0l0ZW1EaXNhYmxlZChpdGVtKSB7XG4gICAgICByZXR1cm4gKHJlYWRPbmx5IHx8IHJlYWRvbmx5KSAmJiAhaXNFcXVhbChpdGVtLCBzZWxlY3RlZEl0ZW0pO1xuICAgIH0sXG4gICAgc3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb25BbmRDaGFuZ2VzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBhY3Rpb25BbmRDaGFuZ2VzO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgdXNlQ29tYm9ib3guc3RhdGVDaGFuZ2VUeXBlcy5JbnB1dEtleURvd25FbnRlcjpcbiAgICAgICAgY2FzZSB1c2VDb21ib2JveC5zdGF0ZUNoYW5nZVR5cGVzLkl0ZW1DbGljazpcbiAgICAgICAgICBhd2FpdGluZ0NoYW5nZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIGlmIGRhdGFPcHRpb25zIHBvcHVsYXRlL2NoYW5nZSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXIsIHVwZGF0ZSB0aGUgc2VsZWN0ZWRJdGVtIHN0YXRlXG4gICAgLy8gaWYgb25lIGhhc24ndCBiZWVuIGZvdW5kIHlldC5cbiAgICBpZiAoZGF0YU9wdGlvbnM/Lmxlbmd0aCAhPT0gZGF0YUxlbmd0aC5jdXJyZW50ICYmIHZhbHVlICYmIHNlbGVjdGVkSXRlbSA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBnZXRTZWxlY3RlZE9iamVjdCh2YWx1ZSwgZGF0YU9wdGlvbnMpO1xuICAgICAgdXBkYXRlU2VsZWN0ZWRJdGVtKHNlbGVjdGVkKTtcbiAgICAgIGRhdGFMZW5ndGguY3VycmVudCA9IGRhdGFPcHRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0sIFtkYXRhT3B0aW9ucywgc2VsZWN0ZWRJdGVtLCB2YWx1ZV0pO1xuICBjb25zdCB2YWx1ZUxhYmVsID0gZGVmYXVsdEl0ZW1Ub1N0cmluZyhzZWxlY3RlZEl0ZW0pIHx8IHBsYWNlaG9sZGVyIHx8ICcnO1xuICBjb25zdCBsYWJlbElkID0gYHNsLWxhYmVsLSR7dGVzdElkfWA7XG4gIGNvbnN0IHZhbHVlSWQgPSBgc2VsZWN0ZWQtJHt0ZXN0SWR9LWl0ZW1gO1xuICBpZiAoYXdhaXRpbmdDaGFuZ2UuY3VycmVudCkge1xuICAgIC8vIGEgdXNlciBoYXMgY2hhbmdlIHRoZSB2YWx1ZSB2aWEgdGhlIGRyb3Bkb3duIGFuZCB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgdmFsdWVcbiAgICAvLyB0byBjb3JyZXNwb25kIHdpdGggdGhlIHN0YXRlLi4uXG4gICAgaWYgKHNlbGVjdGVkSXRlbSAhPT0gbnVsbCAmJiBzZWxlY3RlZEl0ZW0/LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgYXdhaXRpbmdDaGFuZ2UuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgoc2VsZWN0ZWRJdGVtICE9PSBudWxsIHx8XG4gIC8vIGlmIHdlIGNhbiBmaW5kIGEgdmFsaWQgZGF0YU9wdGlvbiB0byBtYXRjaCB0aGUgdmFsdWUgKGZvciBkYXRhT3B0aW9ucyB0aGF0IGhhdmUgdmFsdWU6ICcnKVxuICBnZXRTZWxlY3RlZE9iamVjdCh2YWx1ZSwgZGF0YU9wdGlvbnMpICE9PSBudWxsKSAmJiBzZWxlY3RlZEl0ZW0/LnZhbHVlICE9PSB2YWx1ZSkge1xuICAgIC8vIGNvbmZvcm0gdG8gcG9zdC1tb3VudCB2YWx1ZSBwcm9wIGNoYW5nZXMgZnJvbSBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQsXG4gICAgLy8gd2hldGhlciB0aGUgY2hhbmdlZCB2YWx1ZSBpcyBzb21ldGhpbmcgZW1wdHkgbGlrZSAnJyBvciBudWxsO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gZ2V0U2VsZWN0ZWRPYmplY3QodmFsdWUsIGRhdGFPcHRpb25zKSB8fCB7XG4gICAgICB2YWx1ZVxuICAgIH07XG4gICAgdXBkYXRlU2VsZWN0ZWRJdGVtKG5ld1ZhbHVlKTtcbiAgfVxuXG4gIC8qKiByZW5kZXJPcHRpb25zXHJcbiAgICogIEFsbCBvZiB0aGUgcmVuZGVyaW5nIG9mIHRoZSBvcHRpb25zIGxpc3QgaXMgcGVyZm9ybWVkIGhlcmUuXHJcbiAgICogIFRoaXMgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgcGFzc2VkIGludG8gdGhlIFNlbGVjdGlvbk92ZXJsYXkgJiBTZWxlY3Rpb25MaXN0XHJcbiAgICovXG5cbiAgLy8gSXQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSBpZiAqYWxsIG9mIHRoZSB0aGluZ3MgaXQgdXNlcyBjaGFuZ2UuLi5cbiAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG4gIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gaWYgb3B0aW9ucyBhcmUgZGVsaXZlcmVkIHdpdGggZ3JvdXBpbmdzLCB3ZSBmbGF0dGVuIHRoZSBvcHRpb25zIGZvclxuICAgIC8vIGEgc2V0IG9mIHNlbGVjdGFibGUgaW5kaWNlcy4gR3JvdXAgbGFiZWxzIGFyZSBub3Qgc2VsZWN0YWJsZS5cbiAgICBjb25zdCBmbGF0dGVuZWRPcHRpb25zID0gZmxhdHRlbk9wdGlvbkxpc3Qob3B0aW9ucyk7XG4gICAgLyogbG9hZGluZyBtZXNzYWdlICovXG4gICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChcImxpXCIsIHtcbiAgICAgICAgcm9sZTogXCJvcHRpb25cIixcbiAgICAgICAgY2xhc3NOYW1lOiBjc3Mub3B0aW9uLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogXCJmYWxzZVwiLFxuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL19qc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogbG9hZGluZ01lc3NhZ2VcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIG5vIG9wdGlvbnMgZm91bmQgdGhyb3VnaCBhc3luYyBmaWx0ZXIgKi9cbiAgICBpZiAoZGF0YU9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19qc3goXCJsaVwiLCB7XG4gICAgICAgIHJvbGU6IFwib3B0aW9uXCIsXG4gICAgICAgIGNsYXNzTmFtZTogY3NzLm9wdGlvbixcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9fanN4cyhcInNwYW5cIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXCItXCIsIGVtcHR5TWVzc2FnZSwgXCItXCJdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBubyBvcHRpb25zIGZvdW5kIHRocm91Z2ggZmlsdGVyaW5nICovXG4gICAgaWYgKGZsYXR0ZW5lZE9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19qc3goXCJsaVwiLCB7XG4gICAgICAgIHJvbGU6IFwib3B0aW9uXCIsXG4gICAgICAgIGNsYXNzTmFtZTogY3NzLm9wdGlvbixcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9fanN4cyhcInNwYW5cIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXCItXCIsIGZvcm1hdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6ICdzdHJpcGVzLWNvbXBvbmVudHMuc2VsZWN0aW9uLmVtcHR5TGlzdCdcbiAgICAgICAgICB9KSwgXCItXCJdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW5lZE9wdGlvbnMubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAoaXRlbS52YWx1ZSkge1xuICAgICAgICBjb25zdCByZWR1Y2VkSW5kZXggPSByZWNvbmNpbGVSZWR1Y2VkSW5kZXgoaXRlbSwgcmVkdWNlZExpc3RJdGVtcyk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChcImxpXCIsIHtcbiAgICAgICAgICAuLi5nZXRJdGVtUHJvcHMoe1xuICAgICAgICAgICAgaW5kZXg6IHJlZHVjZWRJbmRleCxcbiAgICAgICAgICAgIG9uTW91c2VVcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgY2xhc3NOYW1lOiBnZXRJdGVtQ2xhc3MoaXRlbSwgcmVkdWNlZEluZGV4LCB7XG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgICBoaWdobGlnaHRlZEluZGV4LFxuICAgICAgICAgICAgZGF0YU9wdGlvbnNcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjaGlsZHJlbjogZm9ybWF0dGVyKHtcbiAgICAgICAgICAgIG9wdGlvbjogaXRlbSxcbiAgICAgICAgICAgIHNlYXJjaFRlcm06IGZpbHRlclZhbHVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSwgYCR7aXRlbS5sYWJlbH0tb3B0aW9uLSR7aX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChcImxpXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjc3MuZ3JvdXBMYWJlbCxcbiAgICAgICAgY2hpbGRyZW46IGZvcm1hdHRlcih7XG4gICAgICAgICAgb3B0aW9uOiBpdGVtLFxuICAgICAgICAgIHNlYXJjaFRlcm06IGZpbHRlclZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9LCBgJHtpdGVtLmxhYmVsfS1oZWFkaW5nLSR7aX1gKTtcbiAgICB9KTtcbiAgfSwgW2xvYWRpbmcsIGZpbHRlclZhbHVlLCBzZWxlY3RlZEl0ZW0sIGhpZ2hsaWdodGVkSW5kZXgsIHZhbHVlLCBvcHRpb25zXSk7XG4gIGNvbnN0IHJlbmRlckZpbHRlcklucHV0ID0gdXNlQ2FsbGJhY2soZmlsdGVyUmVmID0+IC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNzcy5zZWxlY3Rpb25GaWx0ZXJDb250YWluZXIsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9fanN4KFwiaW5wdXRcIiwge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAuLi5nZXRJbnB1dFByb3BzKHtcbiAgICAgICAgcmVmOiBmaWx0ZXJSZWYsXG4gICAgICAgIHZhbHVlOiBmaWx0ZXJWYWx1ZSxcbiAgICAgICAgLy8gc3RvcFByb3BhZ2F0aW9uIHRvIGtlZXAgZnJvbSB1bndhbnRlZGx5IHRyaWdnZXJpbmcgc2hvcnRjdXRzIGFuZFxuICAgICAgICAvLyBhZGRyZXNzIGRvd25zaGlmdCBpc3N1ZXMgd2l0aCBwb3J0YWwgcmVuZGVyaW5nL2Z1bmN0aW9uYWxpdHkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3duc2hpZnQtanMvZG93bnNoaWZ0L2lzc3Vlcy8yODdcbiAgICAgICAgb25LZXlEb3duOiBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXG4gICAgICAgIG9uTW91c2VVcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICB9KSxcbiAgICAgIG9uQ2xpY2s6ICgpID0+IHt9LFxuICAgICAgb25DaGFuZ2U6IGUgPT4gdXBkYXRlRmlsdGVyVmFsdWUoZS50YXJnZXQudmFsdWUpLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IGZvcm1hdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogJ3N0cmlwZXMtY29tcG9uZW50cy5zZWxlY3Rpb24uZmlsdGVyT3B0aW9uc0xhYmVsJ1xuICAgICAgfSwge1xuICAgICAgICBsYWJlbFxuICAgICAgfSksXG4gICAgICBjbGFzc05hbWU6IGNzcy5zZWxlY3Rpb25GaWx0ZXIsXG4gICAgICBwbGFjZWhvbGRlcjogZm9ybWF0TWVzc2FnZSh7XG4gICAgICAgIGlkOiAnc3RyaXBlcy1jb21wb25lbnRzLnNlbGVjdGlvbi5maWx0ZXJPcHRpb25zUGxhY2Vob2xkZXInXG4gICAgICB9KVxuICAgIH0pXG4gIH0pLCBbZmlsdGVyVmFsdWVdKTtcbiAgY29uc3QgZ2V0Q29udHJvbENsYXNzID0gdXNlTWVtbygoKSA9PiBnZXRDbGFzcyh7XG4gICAgZGlydHksXG4gICAgZXJyb3IsXG4gICAgbWFyZ2luQm90dG9tMCxcbiAgICB1c2VWYWxpZFN0eWxlLFxuICAgIHZhbGlkLFxuICAgIHdhcm5pbmdcbiAgfSksIFtlcnJvciwgd2FybmluZywgZGlydHksIHZhbGlkLCB1c2VWYWxpZFN0eWxlLCBtYXJnaW5Cb3R0b20wXSk7XG5cbiAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cblxuICByZXR1cm4gLyojX19QVVJFX18qL19qc3hzKFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogW2xhYmVsICYmIC8qI19fUFVSRV9fKi9fanN4KExhYmVsLCB7XG4gICAgICAuLi5nZXRMYWJlbFByb3BzKHtcbiAgICAgICAgaWQ6IGxhYmVsSWRcbiAgICAgIH0pLFxuICAgICAgcmVhZE9ubHk6IHJlYWRPbmx5IHx8IHJlYWRvbmx5LFxuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxuICAgICAgY2hpbGRyZW46IGxhYmVsXG4gICAgfSksIC8qI19fUFVSRV9fKi9fanN4cyhcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IGNzcy5zZWxlY3Rpb25Db250cm9sQ29udGFpbmVyLFxuICAgICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovX2pzeHMoXCJidXR0b25cIiwge1xuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAuLi5nZXRUb2dnbGVCdXR0b25Qcm9wcyh7XG4gICAgICAgICAgcmVmOiBjb250cm9sUmVmLFxuICAgICAgICAgIHRhYkluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgcmVhZE9ubHksXG4gICAgICAgICAgaWQ6IHRlc3RJZCxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogYCR7bGFiZWxJZH0gJHt2YWx1ZUlkfWBcbiAgICAgICAgfSksXG4gICAgICAgIGNsYXNzTmFtZTogZ2V0Q29udHJvbENsYXNzLFxuICAgICAgICBhdXRvRm9jdXM6IGF1dG9mb2N1cyxcbiAgICAgICAgb25CbHVyOiBvbkJsdXIsXG4gICAgICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBzZWxlY3RlZEl0ZW0/LnZhbHVlLFxuICAgICAgICBjaGlsZHJlbjogWy8qI19fUFVSRV9fKi9fanN4KFwic3BhblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInNyLW9ubHlcIixcbiAgICAgICAgICBjaGlsZHJlbjogZm9ybWF0TWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogJ3N0cmlwZXMtY29tcG9uZW50cy5zZWxlY3Rpb24uY29udHJvbExhYmVsJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pLCAvKiNfX1BVUkVfXyovX2pzeChcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjc3Muc2luZ2xlVmFsdWUsXG4gICAgICAgICAgaWQ6IHZhbHVlSWQsXG4gICAgICAgICAgY2hpbGRyZW46IHZhbHVlTGFiZWxcbiAgICAgICAgfSldXG4gICAgICB9KSwgLyojX19QVVJFX18qL19qc3goXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IGNzcy5zZWxlY3Rpb25FbmRDb250cm9scyxcbiAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9fanN4KFRleHRGaWVsZEljb24sIHtcbiAgICAgICAgICBpY29uOiBcInRyaWFuZ2xlLWRvd25cIlxuICAgICAgICB9KVxuICAgICAgfSksIC8qI19fUFVSRV9fKi9fanN4cyhcImRpdlwiLCB7XG4gICAgICAgIHJvbGU6IFwiYWxlcnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt3YXJuaW5nICYmIC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGAke2Zvcm1TdHlsZXMuZmVlZGJhY2tXYXJuaW5nfWAsXG4gICAgICAgICAgY2hpbGRyZW46IHdhcm5pbmdcbiAgICAgICAgfSksIGVycm9yICYmIC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGAke2Zvcm1TdHlsZXMuZmVlZGJhY2tFcnJvcn1gLFxuICAgICAgICAgIGNoaWxkcmVuOiBlcnJvclxuICAgICAgICB9KV1cbiAgICAgIH0pXVxuICAgIH0pLCAvKiNfX1BVUkVfXyovX2pzeChTZWxlY3Rpb25PdmVybGF5LCB7XG4gICAgICAuLi5yZXN0LFxuICAgICAgY29udHJvbFJlZjogY29udHJvbFJlZixcbiAgICAgIGdldE1lbnVQcm9wczogZ2V0TWVudVByb3BzLFxuICAgICAgaWQ6IHRlc3RJZCxcbiAgICAgIGlzT3BlbjogaXNPcGVuLFxuICAgICAgbGlzdE1heEhlaWdodDogbGlzdE1heEhlaWdodCxcbiAgICAgIG9uQ2hhbmdlRmlsdGVyVmFsdWU6IHVwZGF0ZUZpbHRlclZhbHVlLFxuICAgICAgb3B0aW9uQWxpZ25tZW50OiBvcHRpb25BbGlnbm1lbnQsXG4gICAgICBwb3BwZXI6IHBvcHBlcixcbiAgICAgIHJlbmRlckZpbHRlcklucHV0OiByZW5kZXJGaWx0ZXJJbnB1dCxcbiAgICAgIHJlbmRlck9wdGlvbnM6IHJlbmRlck9wdGlvbnMsXG4gICAgICB1c2VQb3J0YWw6IHVzZVBvcnRhbCxcbiAgICAgIHdpZHRoOiBnZXRDb250cm9sV2lkdGgoY29udHJvbFJlZi5jdXJyZW50KSxcbiAgICAgIGxhYmVsSWQ6IGxhYmVsSWRcbiAgICB9KV1cbiAgfSk7XG59O1xuU2VsZWN0aW9uLmRpc3BsYXlOYW1lID0gXCJTZWxlY3Rpb25cIjtcblNlbGVjdGlvbi5wcm9wVHlwZXMgPSB7XG4gIGFzeW5jRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgYXV0b2ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgZGF0YU9wdGlvbnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuICBkaXJ0eTogUHJvcFR5cGVzLmJvb2wsXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgZW1wdHlNZXNzYWdlOiBQcm9wVHlwZXMubm9kZSxcbiAgZXJyb3I6IFByb3BUeXBlcy5ub2RlLFxuICBmb3JtYXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW5wdXRSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcbiAgbGlzdE1heEhlaWdodDogUHJvcFR5cGVzLnN0cmluZyxcbiAgbG9hZGluZzogUHJvcFR5cGVzLmJvb2wsXG4gIGxvYWRpbmdNZXNzYWdlOiBQcm9wVHlwZXMubm9kZSxcbiAgbWFyZ2luQm90dG9tMDogUHJvcFR5cGVzLmJvb2wsXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgb3B0aW9uQWxpZ25tZW50OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLm5vZGUsXG4gIHBvcHBlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBwb3J0YWw6IGRlcHJlY2F0ZWQoUHJvcFR5cGVzLmVsZW1lbnQsICd1c2UgdGhlIGJvb2xlYW4gdXNlUG9ydGFsIHByb3Agb2YgU2VsZWN0aW9uIGluc3RlYWQnKVxuICB9KSxcbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICByZWFkb25seTogUHJvcFR5cGVzLmJvb2wsXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgdXNlUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgdXNlVmFsaWRTdHlsZTogUHJvcFR5cGVzLmJvb2wsXG4gIHZhbGlkOiBQcm9wVHlwZXMuYm9vbCxcbiAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdhcm5pbmc6IFByb3BUeXBlcy5ub2RlXG59O1xuZXhwb3J0IGRlZmF1bHQgZm9ybUZpZWxkKFNlbGVjdGlvbiwgX3JlZjQgPT4ge1xuICBsZXQge1xuICAgIG1ldGFcbiAgfSA9IF9yZWY0O1xuICByZXR1cm4ge1xuICAgIGRpcnR5OiBtZXRhLmRpcnR5LFxuICAgIGVycm9yOiBtZXRhLnRvdWNoZWQgJiYgbWV0YS5lcnJvciA/IG1ldGEuZXJyb3IgOiAnJyxcbiAgICB2YWxpZDogbWV0YS52YWxpZCxcbiAgICB3YXJuaW5nOiBtZXRhLnRvdWNoZWQgPyBwYXJzZU1ldGEobWV0YSwgJ3dhcm5pbmcnKSA6ICcnXG4gIH07XG59KTtcbjtcblNlbGVjdGlvbi5fX2RvY2dlbkluZm8gPSB7XG4gIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgXCJtZXRob2RzXCI6IFtdLFxuICBcImRpc3BsYXlOYW1lXCI6IFwiU2VsZWN0aW9uXCIsXG4gIFwicHJvcHNcIjoge1xuICAgIFwiZm9ybWF0dGVyXCI6IHtcbiAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IHtcbiAgICAgICAgXCJ2YWx1ZVwiOiBcIih7IG9wdGlvbiwgc2VhcmNoVGVybSB9KSA9PiB7XFxyXFxuICByZXR1cm4gb3B0aW9uID9cXHJcXG4gICAgPE9wdGlvblNlZ21lbnQgc2VhcmNoVGVybT17c2VhcmNoVGVybX0+e29wdGlvbi5sYWJlbH08L09wdGlvblNlZ21lbnQ+IDpcXHJcXG4gICAgbnVsbDtcXHJcXG59XCIsXG4gICAgICAgIFwiY29tcHV0ZWRcIjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImxpc3RNYXhIZWlnaHRcIjoge1xuICAgICAgXCJkZWZhdWx0VmFsdWVcIjoge1xuICAgICAgICBcInZhbHVlXCI6IFwiJzE3NHB4J1wiLFxuICAgICAgICBcImNvbXB1dGVkXCI6IGZhbHNlXG4gICAgICB9LFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcIm9uRmlsdGVyXCI6IHtcbiAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IHtcbiAgICAgICAgXCJ2YWx1ZVwiOiBcIih2YWx1ZSwgZGF0YU9wdGlvbnMpID0+IHtcXHJcXG4gIGNvbnN0IHZhbHVlUkUgPSBuZXcgUmVnRXhwKGBeJHt2YWx1ZX1gLCAnaScpO1xcclxcbiAgY29uc3QgYmFzZUZpbHRlciA9IChvKSA9PiB2YWx1ZVJFLnRlc3Qoby5sYWJlbCk7XFxyXFxuICAvLyBpZiBpdGVtcyBoYXZlIGFuICdvcHRpb25zJyBmaWVsZCwgZmlsdGVyIHRob3NlIGl0ZW1zIGFuZCByZXR1cm4gdGhlIGRhdGFPcHRpb25zIGdyb3VwIHdpdGggdGhlXFxyXFxuICAvLyByZXN1bHRzIGluc2VydGVkLlxcclxcbiAgY29uc3QgZ3JvdXBlZCA9IGRhdGFPcHRpb25zLnNvbWUoKG8pID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCAnb3B0aW9ucycpKTtcXHJcXG4gIGlmIChncm91cGVkKSB7XFxyXFxuICAgIHJldHVybiBkYXRhT3B0aW9ucy5yZWR1Y2UoKG9wdGlvbnMsIG9wdCkgPT4ge1xcclxcbiAgICAgIC8vIGdsb2JhbCwgdW5ncm91cGVkIG9wdGlvbnNcXHJcXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdCwgJ3ZhbHVlJykpIHtcXHJcXG4gICAgICAgIGlmICh2YWx1ZVJFLnRlc3Qob3B0LmxhYmVsKSkge1xcclxcbiAgICAgICAgICByZXR1cm4gWy4uLm9wdGlvbnMsIG9wdF07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0LCAnb3B0aW9ucycpKSB7XFxyXFxuICAgICAgICBjb25zdCBmaWx0ZXJlZE9wdGlvbnMgPSBvcHQub3B0aW9ucy5maWx0ZXIoYmFzZUZpbHRlcik7XFxyXFxuICAgICAgICBpZiAoZmlsdGVyZWRPcHRpb25zLmxlbmd0aCA+IDApIHtcXHJcXG4gICAgICAgICAgcmV0dXJuIFsuLi5vcHRpb25zLCB7IC4uLm9wdCwgb3B0aW9uczogZmlsdGVyZWRPcHRpb25zIH1dO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgICByZXR1cm4gb3B0aW9ucztcXHJcXG4gICAgfSwgW10pO1xcclxcbiAgfVxcclxcbiAgcmV0dXJuIGRhdGFPcHRpb25zLmZpbHRlcihiYXNlRmlsdGVyKTtcXHJcXG59XCIsXG4gICAgICAgIFwiY29tcHV0ZWRcIjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInVzZVZhbGlkU3R5bGVcIjoge1xuICAgICAgXCJkZWZhdWx0VmFsdWVcIjoge1xuICAgICAgICBcInZhbHVlXCI6IFwiZmFsc2VcIixcbiAgICAgICAgXCJjb21wdXRlZFwiOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiYXN5bmNGaWx0ZXJcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZnVuY1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJhdXRvZm9jdXNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9vbFwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJkYXRhT3B0aW9uc1wiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJhcnJheU9mXCIsXG4gICAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICAgIFwibmFtZVwiOiBcIm9iamVjdFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImRpcnR5XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZGlzYWJsZWRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9vbFwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJlbXB0eU1lc3NhZ2VcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJlcnJvclwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJub2RlXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImlkXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJpbnB1dFJlZlwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJ1bmlvblwiLFxuICAgICAgICBcInZhbHVlXCI6IFt7XG4gICAgICAgICAgXCJuYW1lXCI6IFwib2JqZWN0XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIFwibmFtZVwiOiBcImZ1bmNcIlxuICAgICAgICB9XVxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwibGFiZWxcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJsb2FkaW5nXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwibG9hZGluZ01lc3NhZ2VcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJtYXJnaW5Cb3R0b20wXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwibmFtZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwib25CbHVyXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImZ1bmNcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwib25DaGFuZ2VcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZnVuY1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJvbkZvY3VzXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImZ1bmNcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwib3B0aW9uQWxpZ25tZW50XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJwbGFjZWhvbGRlclwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJub2RlXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInBvcHBlclwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJzaGFwZVwiLFxuICAgICAgICBcInZhbHVlXCI6IHtcbiAgICAgICAgICBcInBvcnRhbFwiOiB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjdXN0b21cIixcbiAgICAgICAgICAgIFwicmF3XCI6IFwiZGVwcmVjYXRlZChQcm9wVHlwZXMuZWxlbWVudCwgJ3VzZSB0aGUgYm9vbGVhbiB1c2VQb3J0YWwgcHJvcCBvZiBTZWxlY3Rpb24gaW5zdGVhZCcpXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJyZWFkT25seVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInJlYWRvbmx5XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwicmVxdWlyZWRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9vbFwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJ1c2VQb3J0YWxcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9vbFwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJ2YWxpZFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJ3YXJuaW5nXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Selection/Selection.js\n')}}]);