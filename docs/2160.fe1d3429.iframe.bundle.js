"use strict";(self.webpackChunk_folio_stripes_components=self.webpackChunk_folio_stripes_components||[]).push([[2160],{"./lib/Paneset/Paneset.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ lib_Paneset_Paneset)\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__("./node_modules/react/index.js");\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__("./node_modules/prop-types/index.js");\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__("./node_modules/classnames/index.js");\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/lodash/lodash.js\nvar lodash = __webpack_require__("./node_modules/lodash/lodash.js");\n// EXTERNAL MODULE: ./util/parseCSSUnit.js\nvar parseCSSUnit = __webpack_require__("./util/parseCSSUnit.js");\n// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js\nvar cloneDeep = __webpack_require__("./node_modules/lodash/cloneDeep.js");\nvar cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);\n;// ./lib/Paneset/insertByClientRect.js\n/* insert by clientRect */\n\n/* harmony default export */ const insertByClientRect = ((prevArray, newItem) => {\n  let nextIndex = -1;\n  if (newItem.getRef().current) {\n    const newClientRect = newItem.getRef().current.getBoundingClientRect();\n    nextIndex = prevArray.findIndex(p => {\n      return p.getRef().current.getBoundingClientRect().left > newClientRect.left;\n    });\n  }\n  let newArray;\n  if (nextIndex === -1) {\n    newArray = [...prevArray, newItem];\n  } else if (nextIndex === 0) {\n    newArray = [newItem, ...prevArray];\n  } else {\n    const tempPanes = cloneDeep_default()(prevArray);\n    tempPanes.splice(nextIndex, 0, newItem);\n    newArray = tempPanes;\n  }\n  return newArray;\n});\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js\nvar styleDomAPI = __webpack_require__("./node_modules/style-loader/dist/runtime/styleDomAPI.js");\nvar styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js\nvar insertBySelector = __webpack_require__("./node_modules/style-loader/dist/runtime/insertBySelector.js");\nvar insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\nvar setAttributesWithoutAttributes = __webpack_require__("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");\nvar setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js\nvar insertStyleElement = __webpack_require__("./node_modules/style-loader/dist/runtime/insertStyleElement.js");\nvar insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js\nvar styleTagTransform = __webpack_require__("./node_modules/style-loader/dist/runtime/styleTagTransform.js");\nvar styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/Paneset.css\nvar Paneset = __webpack_require__("./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/Paneset.css");\n;// ./lib/Paneset/Paneset.css\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (styleTagTransform_default());\noptions.setAttributes = (setAttributesWithoutAttributes_default());\n\n      options.insert = insertBySelector_default().bind(null, "head");\n    \noptions.domAPI = (styleDomAPI_default());\noptions.insertStyleElement = (insertStyleElement_default());\n\nvar update = injectStylesIntoStyleTag_default()(Paneset/* default */.A, options);\n\n\n\n\n       /* harmony default export */ const Paneset_Paneset = (Paneset/* default */.A && Paneset/* default */.A.locals ? Paneset/* default */.A.locals : undefined);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js\nvar isEqual = __webpack_require__("./node_modules/lodash/isEqual.js");\nvar isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/PaneResize.css\nvar PaneResize = __webpack_require__("./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/PaneResize.css");\n;// ./lib/Paneset/PaneResize.css\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar PaneResize_options = {};\n\nPaneResize_options.styleTagTransform = (styleTagTransform_default());\nPaneResize_options.setAttributes = (setAttributesWithoutAttributes_default());\n\n      PaneResize_options.insert = insertBySelector_default().bind(null, "head");\n    \nPaneResize_options.domAPI = (styleDomAPI_default());\nPaneResize_options.insertStyleElement = (insertStyleElement_default());\n\nvar PaneResize_update = injectStylesIntoStyleTag_default()(PaneResize/* default */.A, PaneResize_options);\n\n\n\n\n       /* harmony default export */ const Paneset_PaneResize = (PaneResize/* default */.A && PaneResize/* default */.A.locals ? PaneResize/* default */.A.locals : undefined);\n\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__("./node_modules/react/jsx-runtime.js");\n;// ./lib/Paneset/PaneResizeHandle.js\n\n\n\n\n\nconst PaneResizeHandle = /*#__PURE__*/react.forwardRef((_ref, ref) => {\n  let {\n    id,\n    xpos,\n    onMouseDown,\n    active\n  } = _ref;\n  const handleMouseDown = e => {\n    onMouseDown(e, id);\n  };\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    role: "presentation",\n    ref: ref,\n    onMouseDown: handleMouseDown,\n    className: classnames_default()(Paneset_PaneResize.handle, {\n      [Paneset_PaneResize.active]: active\n    }),\n    style: {\n      left: `${xpos}px`\n    },\n    children: "\\xA0"\n  });\n});\nPaneResizeHandle.propTypes = {\n  active: (prop_types_default()).bool,\n  id: (prop_types_default()).string,\n  onMouseDown: (prop_types_default()).func,\n  xpos: (prop_types_default()).number\n};\nPaneResizeHandle.displayName = \'PaneResizeHandle\';\n/* harmony default export */ const Paneset_PaneResizeHandle = (PaneResizeHandle);\n;\nPaneResizeHandle.__docgenInfo = {\n  "description": "",\n  "methods": [],\n  "displayName": "PaneResizeHandle",\n  "props": {\n    "active": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "id": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "onMouseDown": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "xpos": {\n      "description": "",\n      "type": {\n        "name": "number"\n      },\n      "required": false\n    }\n  }\n};\n;// ./lib/Paneset/PaneResizeCursor.js\n\n\n\n\n\nconst PaneResizeCursor = /*#__PURE__*/react.forwardRef((_ref, ref) => {\n  let {\n    visible,\n    xpos\n  } = _ref;\n  // the cursor hover aria is expanded by a transparent container div that\'s 20px wide.\n  // the dotted border is centered, so the placement of the div is at the mouse x position minus\n  // 10px.\n  const cursorHoverHalf = 10;\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: classnames_default()(Paneset_PaneResize.cursorHover, {\n      [Paneset_PaneResize.cursorActive]: visible\n    }),\n    style: {\n      left: `${xpos - cursorHoverHalf}px`\n    },\n    ref: ref,\n    hidden: !visible,\n    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: Paneset_PaneResize.cursor,\n      children: "\\xA0"\n    })\n  });\n});\nPaneResizeCursor.propTypes = {\n  visible: (prop_types_default()).bool,\n  xpos: (prop_types_default()).number\n};\nPaneResizeCursor.displayName = \'PaneResizeCursor\';\n/* harmony default export */ const Paneset_PaneResizeCursor = (PaneResizeCursor);\n;\nPaneResizeCursor.__docgenInfo = {\n  "description": "",\n  "methods": [],\n  "displayName": "PaneResizeCursor",\n  "props": {\n    "visible": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "xpos": {\n      "description": "",\n      "type": {\n        "name": "number"\n      },\n      "required": false\n    }\n  }\n};\n// EXTERNAL MODULE: ./lib/Paneset/ResizeContext.js\nvar ResizeContext = __webpack_require__("./lib/Paneset/ResizeContext.js");\n;// ./lib/Paneset/PaneResizeContainer.js\n\n\n\n\n\n\n\n\n\n\nconst PaneResizeContainer = _ref => {\n  let {\n    isRoot,\n    children,\n    onElementResize,\n    parentElement,\n    resizeContainerRef\n  } = _ref;\n  const [dragging, setDragging] = (0,react.useState)(false);\n  const [cursorX, setCursorX] = (0,react.useState)(0);\n  const [handles, setHandles] = (0,react.useState)([]);\n  const [activeHandle, setActiveHandle] = (0,react.useState)(null);\n  const [update, setUpdate] = (0,react.useState)(0); // eslint-disable-line no-unused-vars\n  const [blocking, setBlocking] = (0,react.useState)(null);\n  let container = (0,react.useRef)();\n  if (resizeContainerRef) {\n    container = resizeContainerRef;\n  }\n  const handleData = (0,react.useRef)([]);\n  const containerRect = (0,react.useRef)();\n  const activeRef = (0,react.useRef)();\n  const observer = (0,react.useRef)();\n  const observerCallback = (0,react.useRef)(mutationList => {\n    setBlocking(curBlocker => {\n      let blocker = curBlocker;\n      mutationList.forEach(m => {\n        if (m.type === \'childList\') {\n          // check against full container bounds\n          const blockingNode = Array.from(m.addedNodes).find(n => {\n            const newBox = n?.getBoundingClientRect();\n            return newBox && containerRect.current && newBox.left <= containerRect.current.left && newBox.width >= containerRect.current.width;\n          });\n          if (blockingNode) {\n            blocker = {\n              id: blockingNode.id,\n              class: blockingNode.className,\n              style: blockingNode.getAttribute(\'style\')\n            };\n          }\n          if (typeof curBlocker === \'object\') {\n            if (Array.from(m.removedNodes).find(n => {\n              // eslint-disable-line consistent-return\n              // we look for the removal of a node matching the blocker...\n              const candidate = {\n                id: n.id,\n                class: n.className,\n                style: n.getAttribute(\'style\')\n              };\n              return isEqual_default()(blocker, candidate);\n            })) {\n              blocker = null;\n            }\n          }\n        }\n      });\n      return blocker;\n    });\n  }).current;\n  const onWindowResize = (0,react.useCallback)(() => {\n    containerRect.current = container.current?.getBoundingClientRect();\n    setUpdate(u => u + 1);\n  }, []);\n\n  // set up the mutation observer for overlapping element once we get a usable parentElement prop.\n  (0,react.useEffect)(() => {\n    if (isRoot) {\n      const observerOptions = {\n        childList: true\n      };\n      if (parentElement) {\n        observer.current = new MutationObserver(observerCallback);\n        observer.current.observe(parentElement, observerOptions);\n      }\n    }\n    return () => {\n      if (observer.current) observer.current.disconnect();\n    };\n  }, [parentElement, isRoot, observerCallback]);\n  (0,react.useEffect)(() => {\n    if (isRoot) {\n      if (!dragging && activeHandle !== null) {\n        const {\n          current: handleList\n        } = handleData;\n        const resizedIndex = handleList.findIndex(h => h.id === activeHandle.id);\n        if (resizedIndex !== -1) {\n          handleList[resizedIndex].x = cursorX;\n          onElementResize({\n            positions: handleList,\n            activeHandle,\n            cursorX,\n            containerRect: containerRect.current\n          });\n        }\n        setActiveHandle(null);\n      }\n    }\n  }, [dragging, activeHandle, onElementResize, cursorX, isRoot]);\n  (0,react.useEffect)(() => {\n    // eslint-disable-line consistent-return\n    if (isRoot) {\n      window.addEventListener(\'resize\', onWindowResize);\n      return function cleanup() {\n        if (observer.current) observer.current.disconnect();\n        window.removeEventListener(\'resize\', onWindowResize);\n        document.removeEventListener(\'mousemove\', updateCursor); // eslint-disable-line no-use-before-define\n        document.removeEventListener(\'mouseup\', handleMouseUp); // eslint-disable-line no-use-before-define\n      };\n    }\n  }, []); // eslint-disable-line\n\n  const updateCursor = (0,react.useCallback)(e => {\n    if (containerRect.current) {\n      let nextX = e.clientX - containerRect.current.left;\n      const hdata = handleData.current;\n      const handleOffset = 20; // some margin on the bounds of a resize handle\n      const prevHandle = hdata[activeRef.current - 1] || {\n        x: 0\n      };\n      const nextHandle = hdata[activeRef.current + 1] || {\n        x: containerRect.current.width\n      };\n      if (nextX < prevHandle.x + handleOffset) {\n        nextX = prevHandle.x + handleOffset;\n      } else if (nextX > nextHandle.x - handleOffset) {\n        nextX = nextHandle.x - handleOffset;\n      }\n      setCursorX(nextX);\n    }\n  }, []);\n  const handleMouseUp = (0,react.useCallback)(() => {\n    document.removeEventListener(\'mousemove\', updateCursor);\n    document.removeEventListener(\'mouseup\', handleMouseUp);\n    document.body.style.userSelect = \'auto\';\n    document.body.style.webkitUserSelect = \'auto\';\n    document.body.style.msUserSelect = \'auto\';\n    document.body.style.msUserSelect = \'auto\';\n    setDragging(false);\n  }, [updateCursor]);\n  const handleHandleMouseDown = (0,react.useCallback)((e, id) => {\n    setCursorX(e.clientX);\n    setDragging(true);\n    const handleIndex = handles.findIndex(h => h.id === id);\n    const handleDataIndex = handleData.current.findIndex(h => h.id === id);\n    setActiveHandle(handles[handleIndex]);\n    activeRef.current = handleDataIndex;\n    document.addEventListener(\'mousemove\', updateCursor);\n    document.addEventListener(\'mouseup\', handleMouseUp);\n    document.body.style.userSelect = \'none\';\n    document.body.style.webkitUserSelect = \'none\';\n    document.body.style.msUserSelect = \'none\';\n    document.body.style.mozUserSelect = \'none\';\n  }, [handleMouseUp, handles, updateCursor]);\n  const registerHandle = _ref2 => {\n    let {\n      id,\n      elementId,\n      getRef\n    } = _ref2;\n    setHandles(curHandles => {\n      if (curHandles.findIndex(h => h.id === id) === -1) {\n        return insertByClientRect(curHandles, {\n          id,\n          elementId,\n          getRef\n        });\n      }\n      return curHandles;\n    });\n  };\n  const removeHandle = id => {\n    setHandles(curHandles => {\n      const indexToRemove = curHandles.findIndex(h => h.id === id);\n      if (indexToRemove !== -1) {\n        const temp = cloneDeep_default()(curHandles);\n        temp.splice(indexToRemove, 1);\n        return temp;\n      }\n      return curHandles;\n    });\n  };\n  const renderHandles = (0,react.useCallback)(() => {\n    handleData.current = [];\n    const handleElements = handles.map(h => {\n      const rect = h.getRef()?.current?.getBoundingClientRect();\n      if (rect) {\n        if (rect.left === 0) {\n          handleData.current.push({\n            id: h.id,\n            elementId: h.elementId,\n            x: 0,\n            y: 50\n          });\n          return false;\n        }\n        if (!containerRect.current) {\n          containerRect.current = container.current?.getBoundingClientRect();\n        }\n        const newLeft = rect.left - (containerRect.current ? containerRect.current.left : 0);\n        const top = rect.top - (containerRect.current ? containerRect.current.top : 0);\n        handleData.current.push({\n          id: h.id,\n          elementId: h.elementId,\n          x: newLeft,\n          y: top\n        });\n        return /*#__PURE__*/(0,jsx_runtime.jsx)(Paneset_PaneResizeHandle, {\n          id: h.id,\n          xpos: newLeft - 3,\n          active: activeHandle && h.id === activeHandle.id,\n          onMouseDown: handleHandleMouseDown\n        }, h.id);\n      }\n      return null;\n    });\n    return handleElements;\n  }, [activeHandle, handleHandleMouseDown, handles]);\n\n  // this is the equivalent of `forceUpdate` for functional components.\n  const updateHandle = () => {\n    if (containerRect.current) {\n      setUpdate(u => u + 1);\n    }\n  };\n  const suspend = () => {\n    setBlocking({\n      setByLayer: true\n    });\n  };\n  const resume = () => {\n    setBlocking(null);\n  };\n  if (isRoot) {\n    return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(ResizeContext/* ResizeProvider */.uU, {\n        value: {\n          registerHandle,\n          updateHandle,\n          removeHandle,\n          suspend,\n          resume\n        },\n        children: children\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        ref: container,\n        className: Paneset_PaneResize.container,\n        children: [!blocking && renderHandles(), /*#__PURE__*/(0,jsx_runtime.jsx)(Paneset_PaneResizeCursor, {\n          visible: dragging,\n          activeId: activeHandle,\n          xpos: cursorX\n        })]\n      })]\n    });\n  }\n  return children;\n};\nPaneResizeContainer.propTypes = {\n  children: prop_types_default().oneOfType([prop_types_default().arrayOf((prop_types_default()).node), (prop_types_default()).node]),\n  isRoot: (prop_types_default()).bool,\n  onElementResize: (prop_types_default()).func,\n  parentElement: prop_types_default().instanceOf(Element),\n  resizeContainerRef: prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).func])\n};\n/* harmony default export */ const Paneset_PaneResizeContainer = (PaneResizeContainer);\n;\nPaneResizeContainer.__docgenInfo = {\n  "description": "",\n  "methods": [],\n  "displayName": "PaneResizeContainer",\n  "props": {\n    "children": {\n      "description": "",\n      "type": {\n        "name": "union",\n        "value": [{\n          "name": "arrayOf",\n          "value": {\n            "name": "node"\n          }\n        }, {\n          "name": "node"\n        }]\n      },\n      "required": false\n    },\n    "isRoot": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "onElementResize": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "parentElement": {\n      "description": "",\n      "type": {\n        "name": "instanceOf",\n        "value": "Element"\n      },\n      "required": false\n    },\n    "resizeContainerRef": {\n      "description": "",\n      "type": {\n        "name": "union",\n        "value": [{\n          "name": "object"\n        }, {\n          "name": "func"\n        }]\n      },\n      "required": false\n    }\n  }\n};\n// EXTERNAL MODULE: ./lib/Paneset/PanesetContext.js\nvar PanesetContext = __webpack_require__("./lib/Paneset/PanesetContext.js");\n;// ./lib/Paneset/Paneset.js\n\n\n\n\n\n\n\n\n\n\n/* Panes\n*  Panesets hold pass an API down to panes via React context that registers\n*  the pane and allows Paneset to track the widths of each mounted pane\n*  so that they may be appropriately resized. increasing the size of one makes another shrink.\n*  Panesets also handle shrinking or growing the panes as the window is resized.\n*/\n\n/* Dataflow\n*  Pane-resizing:\n*  handlePaneResize() -> resizePanes(), updateLayoutCache()\n*  Window resizing:\n*  resizeToContainer() -> updateLayoutCache(), resizePanes()\n*  Adding a pane:\n*  registerPane() ->\n      insertByClientRect(), calcWidthsAndResize() -> resizeCachedSizeToFit(), resizePanes(), updateLayoutCache()\n*/\n\n/* Data shapes:\n*\n*  widths - (used by calcWidths()) are in the shape of { id: <string>, defaultWidth: <string> }\n*\n*  layoutCache -  (held by state) is an array of objects where keys are id\'s and values are CSS-string\n*    values (eg \'327px\', \'24%\') in the shape of { <paneid string>: <width string> }\n*    layoutCache items represent different combinations of panes (1, 2, 3, n ) panes and\n*    dictate the widths to be used when that particular set of panes mounts.\n*    LayoutCache is held by the paneset\'s state to be used and re-applied when particular set of\n*    panes is re-mounted. In the persisted paneset smart-component, this\n*    cache is saved to localStorage and brought back into the component via props (so it survives switching apps)\n*\n*  pane array - the panes (on mount) register a collection of data and functions to state for easy access within\n*    this component\n*    including their defaultWidth prop, a function to get their outer element, and their setStyle method.\n*/\n\nconst defaultProps = {\n  defaultWidth: \'fill\',\n  onLayout: () => null,\n  initialLayouts: []\n};\nfunction getNewPanewidthObject(key, CSSvalue, proportionalChange) {\n  const unit = (0,parseCSSUnit/* default */.A)(CSSvalue);\n  let newWidth = CSSvalue;\n  switch (unit) {\n    case \'percent\':\n      newWidth = parseFloat(CSSvalue, 10) * proportionalChange;\n      newWidth = `${newWidth}%`;\n      break;\n    case \'vw\':\n      break;\n    case \'px\':\n      newWidth = Math.ceil(parseInt(CSSvalue, 10) * proportionalChange);\n      newWidth = `${newWidth}px`;\n      break;\n    case \'em\':\n      newWidth = Math.ceil(parseInt(CSSvalue, 10) * 14 * proportionalChange);\n      newWidth = `${newWidth / 14}em`;\n      break;\n    case \'rem\':\n      newWidth = Math.ceil(parseInt(CSSvalue, 10) * 14 * proportionalChange);\n      newWidth = `${newWidth / 14}rem`;\n      break;\n    default:\n      break;\n  }\n  return {\n    id: key,\n    defaultWidth: newWidth\n  };\n}\nfunction isUnitPixelBased(cssString) {\n  const pixelValues = [\'px\', \'em\', \'rem\'];\n  return pixelValues.some(pv => cssString.includes(pv));\n}\nclass Paneset_Paneset_Paneset extends react.Component {\n  constructor(props) {\n    var _this;\n    super(props);\n    _this = this;\n    // resizeToContainer - called when the window is resized.\n    // Resizes panes to fit the window width *or the width of the containing paneset(if nested.)\n    // compares the current window / container width to the total width of the\n    // pane elements and resizes them via a multiplier.\n    // if the window is resized to twice as large, panes are resized to twice the pixel size.\n    this.resizeToContainer = () => {\n      // no sense doing all this math if the component has already unmounted\n      if (!this._isMounted) {\n        return;\n      }\n\n      // pick the active layout cache entry - will contain matching id\'s and number of id\'s...\n      const paneIds = [];\n      this.state.panes.forEach(p => paneIds.push(p.id));\n      let currentWidth;\n      if (!this.props.paneset) {\n        currentWidth = window.innerWidth;\n      } else {\n        currentWidth = this.container.current?.getBoundingClientRect().width;\n      }\n      let totalWidth = 0;\n\n      // check for cached layout covers instances where the keys of the object may not be in the same order as\n      // the "paneId" array.\n      const matchingCacheIndex = this.state.layoutCache?.findIndex(c => {\n        const cacheIds = Object.keys(c);\n        if (cacheIds.length !== paneIds.length) return false;\n        return cacheIds.every(id => paneIds.includes(id));\n      }) ?? -1;\n      if (matchingCacheIndex !== -1) {\n        const matchingLCache = this.state.layoutCache[matchingCacheIndex];\n        // set array up with defaultWidth and id...pass to calc widths.\n        const tempPanesList = [];\n        if (currentWidth) {\n          // get an actual width of the paneset...\n          totalWidth = this.getChildPanesTotalWidth();\n\n          // if the totalWidth is 0, panes haven\'t been sized yet, so go ahead and calcWidths/resize...\n          if (totalWidth === 0) {\n            const widths = this.calcWidths(this.state.panes);\n            this.resizePanes(this.state.panes, widths);\n            return;\n          }\n\n          // check actual width against width of containing element... this prevents continued proportional resizes.\n          if (Math.floor(totalWidth) !== currentWidth) {\n            const proportionalChange = currentWidth / totalWidth;\n            for (const p in matchingLCache) {\n              if (Object.prototype.hasOwnProperty.call(matchingLCache, p)) {\n                const newPO = getNewPanewidthObject(p, matchingLCache[p], proportionalChange);\n                tempPanesList.push(newPO);\n              }\n            }\n            this.setState(curr => {\n              const tempCache = (0,lodash.cloneDeep)(curr.layoutCache);\n              tempCache.splice(matchingCacheIndex, 1);\n              return {\n                layoutCache: tempCache\n              };\n            }, () => {\n              // // adjust the layout cache relative to the new client rect size\n              // // size panes accordingly.\n              const newWidths = this.calcWidths(tempPanesList);\n\n              // be sure and update the so that we can use this on the next resize...\n              this.previousContainerWidth = currentWidth;\n              const changeType = \'windowResize\';\n              this.updateLayoutCache(newWidths, changeType);\n              this.resizePanes(this.state.panes, newWidths);\n              this.resizeNestedTO = setTimeout(this.resizeNestedPanesets);\n            });\n          } else {\n            // even if the width of the outside containers fills the window (currentWidth === totalWidth) the panes within\n            // nested panesets may need resizing...\n            this.setState({\n              changeType: \'windowResizeNestedPanesetPanes\'\n            },\n            // eslint-disable-line react/no-unused-state\n            () => {\n              this.resizeNestedTO = setTimeout(this.resizeNestedPanesets);\n            });\n          }\n        }\n      } else {\n        const tempCache = {};\n        const tempPanesList = [];\n        totalWidth = this.getChildPanesTotalWidth();\n\n        // if panes don\'t fill the container, resize them as well as nested panesets.\n        if (Math.floor(totalWidth) !== currentWidth) {\n          const proportionalChange = currentWidth / totalWidth;\n          for (const p in tempCache) {\n            if (Object.prototype.hasOwnProperty.call(tempCache, p)) {\n              const newPO = getNewPanewidthObject(p, tempCache[p], proportionalChange);\n              tempPanesList.push(newPO);\n            }\n          }\n          const newWidths = this.calcWidths(tempPanesList);\n          this.setState({\n            changeType: \'windowResizeUncached\'\n          },\n          // eslint-disable-line react/no-unused-state\n          () => {\n            this.resizePanes(this.state.panes, newWidths);\n            this.resizeNestedTO = setTimeout(this.resizeNestedPanesets);\n          });\n        } else {\n          // even if the width of the outside containers fills the window (currentWidth === totalWidth) the panes within\n          // nested panesets may need resizing...\n          this.setState({\n            changeType: \'windowResizeNestedUncached\'\n          },\n          // eslint-disable-line react/no-unused-state\n          () => {\n            this.resizeNestedTO = setTimeout(this.resizeNestedPanesets);\n          });\n        }\n      }\n    };\n    this.resizeNestedPanesets = () => {\n      if (this._isMounted) {\n        this.state.panes.forEach(p => {\n          if (p.isPaneset) {\n            p.getInstance().resizeToContainer();\n          }\n        });\n      }\n      this.resizeNestedTO = null;\n    };\n    // return total width of child panes of this and any nested panesets.\n    this.getChildPanesTotalWidth = function () {\n      let panesList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.panes;\n      let totalWidth = 0;\n      panesList.forEach(p => {\n        if (p.isPaneset) {\n          totalWidth += p.getChildPanesTotalWidth();\n        } else {\n          const elem = p.getRef();\n          if (elem.current) {\n            totalWidth += elem.current.getBoundingClientRect().width;\n          }\n        }\n      });\n      return totalWidth;\n    };\n    this.handleWindowResize = () => {\n      const {\n        isRoot,\n        paneset\n      } = this.props;\n      if (isRoot || !paneset) {\n        this.resizeToContainer();\n      }\n    };\n    this.isThisMounted = () => this._isMounted;\n    this.getContainer = () => this.container.current;\n    this.getTopmostContainer = () => {\n      const {\n        paneset,\n        isRoot\n      } = this.props;\n      if (!isRoot && paneset) {\n        return paneset.getTopmostContainer();\n      }\n      return this.getContainer();\n    };\n    this.getClassName = () => {\n      const {\n        nested,\n        static: propsStatic\n      } = this.props;\n      return classnames_default()([{\n        [Paneset_Paneset.nested]: nested\n      }, {\n        [Paneset_Paneset.static]: propsStatic\n      }, Paneset_Paneset.paneset]);\n    };\n    this.setStyle = () => {\n      if (this.isThisMounted()) {\n        const {\n          paneset,\n          isRoot\n        } = this.props;\n\n        // for nested, non-root panesets, we resize their element to the edge of the screen.\n        // this resolves a cropping behavior (impetus for STCOM-953) and allows\n        // paneset to accurately resize its children (overflow: hidden)\n        if (paneset && !isRoot) {\n          const containerBounds = this.container.current?.getBoundingClientRect();\n          if (containerBounds.right < window.offsetWidth) {\n            this.setState(curState => {\n              const {\n                left,\n                right\n              } = containerBounds;\n              const newStyle = {\n                flex: `0 0 ${right - left}px`\n              };\n              return {\n                changeType: \'nested-resize-end\',\n                style: {\n                  ...curState.style,\n                  ...newStyle\n                }\n              };\n            });\n          }\n        }\n      }\n    };\n    this.resizePanes = (panes, widths) => {\n      if (widths !== null) {\n        panes.forEach(pane => {\n          const styleObject = {\n            flex: `0 0 ${widths[pane.id]}`\n          };\n          if (!pane.transitioning) {\n            styleObject.left = \'0px\';\n          }\n          pane.setStyle(styleObject);\n        });\n      }\n    };\n    this.removePane = function () {\n      let shouldResize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      _this.setState(oldState => {\n        // accounts for odd situations where multiple Panes are dismissed/dismounted at once...\n        // simply filters out any that have dismounted.\n        const newPanes = oldState.panes.filter(p => p.isThisMounted());\n        const newState = Object.assign({}, oldState);\n        newState.panes = newPanes;\n        newState.changeType = \'removed\';\n        return newState;\n      }, () => {\n        if (shouldResize) _this.calcWidthsAndResize(\'removed\');\n      });\n    };\n    this.registerPane = paneObject => {\n      this.setState(oldState => {\n        let newState = Object.assign({}, oldState);\n        // if the new pane has a transition just set its starting appearance...\n        // otherwise resize all the panes...\n        if (paneObject.transition !== \'none\') {\n          this.transitionStart(paneObject);\n          this.resizePanes(newState.panes, this.widths); // pass cached widths\n          newState.panes.push(paneObject);\n          this.interval = setTimeout(() => {\n            this.transitionEnd(paneObject);\n            this.interval = null;\n          });\n        } else {\n          // check for duplicate id\'s before registering. Registration happens on mount.\n          // This will help with mount-twice strict mode strangeness\n          const paneExists = newState.panes.findIndex(p => p.id === paneObject.id);\n          if (paneExists === -1) {\n            // insert sorted by left coordinate of clientrect...\n            const newPanes = insertByClientRect(newState.panes, paneObject);\n            newState = Object.assign(newState, {\n              panes: newPanes,\n              changeType: \'added\'\n            });\n            // newState = this.insertPaneObject(newState, paneObject);\n          }\n        }\n        return newState;\n      }, () => {\n        this.calcWidthsAndResize(\'added\');\n      });\n    };\n    // sometimes the cached sizes might not match up to the actual container\n    // due the window being a different size when the cache was created.\n    // If that\'s true, scale the cached sizes accordingly.\n    this.resizeCachedSizesToFit = layoutIndex => {\n      const {\n        layoutCache\n      } = this.state;\n      const {\n        paneset\n      } = this.props;\n      const layoutObject = layoutCache[layoutIndex];\n      const layoutUnitTypes = {};\n      let newCacheObject = {};\n      if (!paneset) {\n        // sum the pixels...\n        let totalWidth = 0;\n        let value;\n        for (const p in layoutObject) {\n          if (layoutObject[p]) {\n            const unit = (0,parseCSSUnit/* default */.A)(layoutObject[p]);\n            layoutUnitTypes[p] = unit;\n            if (unit === \'px\') {\n              value = Math.ceil(parseInt(layoutObject[p], 10));\n              totalWidth += value;\n            } else if (unit === \'percent\') {\n              value = parseFloat(layoutObject[p], 10) / 100 * (this.containerWidth || window.innerWidth);\n              totalWidth += value;\n            } else {\n              return null;\n            }\n          }\n        }\n\n        // if all panes are non-pixel, resize the last pane\n        // if the percentages don\'t add up to 100% for panesets of 3 or more panes\n        if (Object.values(layoutUnitTypes).every(v => v === \'percent\' || v === \'vw\')) {\n          const widths = Object.keys(layoutObject);\n          if (widths.length > 2) {\n            let totalPercentWidth = 0;\n            const newWidth = {};\n            widths.forEach((w, i) => {\n              value = parseInt(layoutObject[w], 10);\n              if (i === widths.length - 1) {\n                newWidth.id = w;\n                newWidth.defaultWidth = `${100 - totalPercentWidth}%`;\n              } else {\n                totalPercentWidth += value;\n              }\n            });\n            newCacheObject = {\n              ...newCacheObject,\n              [newWidth.id]: newWidth.defaultWidth\n            };\n            this.previousContainerWidth = window.innerWidth;\n            return {\n              ...layoutObject,\n              ...newCacheObject\n            };\n          }\n          return null;\n        }\n\n        // if the window size has not changed, the cached pane widths may still need to be validated...\n        if (Math.abs(this.previousContainerWidth - window.innerWidth) < 1) {\n          if (Math.abs(this.previousContainerWidth - totalWidth) > 1) {\n            const proportion = this.previousContainerWidth / totalWidth;\n            for (const p in layoutObject) {\n              if (layoutObject[p] && isUnitPixelBased(layoutUnitTypes[p])) {\n                const newWidth = getNewPanewidthObject(p, layoutObject[p], proportion);\n                newCacheObject = {\n                  ...newCacheObject,\n                  [newWidth.id]: newWidth.defaultWidth\n                };\n              }\n            }\n            this.previousContainerWidth = window.innerWidth;\n            return {\n              ...layoutObject,\n              ...newCacheObject\n            };\n          } else {\n            return layoutCache[layoutIndex];\n          }\n        } else {\n          this.resizeToContainer();\n        }\n      }\n      return null;\n    };\n    this.calcWidthsAndResize = changeType => {\n      this.widthsRAF = requestAnimationFrame(() => {\n        let widths;\n        const nextLayout = {};\n        this.state.panes.forEach(p => {\n          nextLayout[p.id] = 0;\n        });\n        const sizesCached = this.cachedLayoutIndex(nextLayout);\n        const toApply = this.props.onLayout({\n          changeType,\n          nextLayout,\n          layoutCached: sizesCached === -1,\n          layoutCache: this.state.layoutCache,\n          widths: sizesCached !== -1 ? null : this.state.layoutCache[sizesCached]\n        });\n        if (toApply !== null && sizesCached === -1) {\n          widths = toApply;\n        } else if (sizesCached !== -1) {\n          widths = this.resizeCachedSizesToFit(sizesCached) || this.state.layoutCache[sizesCached];\n        } else {\n          widths = this.calcWidths(this.state.panes);\n        }\n        this.resizePanes(this.state.panes, widths);\n        this.updateLayoutCache(widths, changeType);\n      });\n    };\n    this.transitionStart = pane => {\n      if (pane.transition === \'slide\') {\n        const styleObject = {};\n        if (!Number.isNaN(parseInt(pane.defaultWidth, 10))) {\n          styleObject.flex = `0 0 ${pane.defaultWidth}`;\n        }\n        styleObject.left = \'100vw\';\n        styleObject.transition = \'left .25s ease\';\n        pane.transitioning = true;\n        pane.setStyle(styleObject);\n      }\n    };\n    this.transitionEnd = pane => {\n      pane.transitioning = false;\n      this.calcWidthsAndResize(\'endedTransition\');\n    };\n    this.isRegistered = id => {\n      const pane = this.state.panes.filter(p => p.id === id)[0];\n      return !!pane;\n    };\n    this.handleClose = (id, callback) => {\n      const pane = this.state.panes.filter(p => p.id === id)[0];\n      if (pane.transition !== \'none\') {\n        this.transitionStart(pane);\n        this.removePane();\n        this.transitionEnd(pane);\n        if (callback) {\n          this.transitionCallbackTO = setTimeout(() => {\n            callback();\n          }, 300);\n        }\n      } else {\n        this.removePane();\n        if (callback) {\n          callback();\n        }\n      }\n    };\n    this.calcWidths = panes => {\n      // find all static widths.\n      const {\n        paneset\n      } = this.props;\n      let staticSpace = 0;\n      const dynamics = [];\n      const resWidths = {};\n      const container = this.getContainer();\n      if (!container) {\n        this.widths = resWidths;\n        return resWidths;\n      }\n      let containerWidth = container.offsetWidth;\n\n      // if containerWidth is 0, use the windowWidth to avoid dividing by 0...\n      if (containerWidth === 0 && !paneset) {\n        containerWidth = window.innerWidth;\n      }\n      panes.forEach(pane => {\n        if (pane.staticWidth && this.previousContainerWidth === containerWidth) {\n          staticSpace += pane.staticWidth;\n        } else {\n          const currentPaneWidth = parseInt(pane.defaultWidth, 10);\n          // if we can\'t get an int from default width, it\'s something dynamic like \'fill\'\n          if (Number.isNaN(currentPaneWidth)) {\n            dynamics.push(pane.id);\n          } else {\n            // parse unit\n            const unit = (0,parseCSSUnit/* default */.A)(pane.defaultWidth);\n            // convert to pixels\n            let parsedWidth;\n            switch (unit) {\n              case \'percent\':\n              case \'vw\':\n                parsedWidth = currentPaneWidth * 0.01 * containerWidth;\n                break;\n              case \'px\':\n                parsedWidth = currentPaneWidth;\n                break;\n              case \'em\':\n              case \'rem\':\n                // system rem of 14\n                parsedWidth = currentPaneWidth * 14;\n                break;\n              default:\n                parsedWidth = currentPaneWidth;\n            }\n            staticSpace += parsedWidth;\n            pane.staticWidth = parsedWidth;\n          }\n        }\n      });\n      const staticPercent = (containerWidth - staticSpace) / containerWidth * 100;\n      const basePercentage = staticPercent / Math.max(Object.keys(dynamics).length, 1);\n      panes.forEach((pane, i) => {\n        if (dynamics.indexOf(pane.id) !== -1) {\n          resWidths[pane.id] = `${basePercentage}%`;\n        } else {\n          resWidths[pane.id] = panes[i].defaultWidth;\n        }\n      });\n      this.widths = resWidths;\n      return resWidths;\n    };\n    this.getRef = () => this.container;\n    this.getInstance = () => this;\n    /**\n     * cachedLayoutIndex\n     * Search state.layoutCache for an object whose keys exactly match those\n     * in the candidate.\n     * @param {object} candidate\n     * @returns int index in state.layoutCache of the matching cache, or -1\n     */\n    this.cachedLayoutIndex = candidate => {\n      return this.state.layoutCache?.findIndex(cache => {\n        const cacheKeys = Object.keys(cache);\n        const candidateKeys = Object.keys(candidate);\n        if (cacheKeys.length === candidateKeys.length) {\n          return cacheKeys.every(ck => candidateKeys.indexOf(ck) !== -1);\n        }\n        return false;\n      }) ?? -1;\n    };\n    this.updateLayoutCache = layoutMap => {\n      if (this.isThisMounted()) {\n        this.setState(_ref => {\n          let {\n            layoutCache\n          } = _ref;\n          // find duplicates with like lengths, id\'s...\n          const layoutIndex = this.cachedLayoutIndex(layoutMap);\n          if (layoutIndex !== -1) {\n            const tempCache = (0,lodash.cloneDeep)(layoutCache);\n            tempCache[layoutIndex] = layoutMap;\n            return {\n              layoutCache: tempCache\n            };\n          }\n          return {\n            layoutCache: [...layoutCache, layoutMap],\n            changeType: \'resize\'\n          };\n        }, () => {\n          // only call the outside cache update IF all panes have non-generated ids.\n          // otherwise, the cache is appended different every time a pane with a different generated id mounts.\n          if (this.props.onResize && this.state.panes.every(p => p.hasGeneratedId === false)) {\n            this.props.onResize({\n              currentLayout: layoutMap,\n              layoutCache: this.state.layoutCache\n            });\n          }\n        });\n      }\n    };\n    // Accepts the positions of handles, the client rect of the container.\n    this.handlePaneResize = _ref2 => {\n      let {\n        positions,\n        containerRect,\n        ...rest\n      } = _ref2;\n      const {\n        panes\n      } = this.state;\n      const newWidths = {};\n      const otherWidths = [];\n      positions.forEach((pos, i) => {\n        const nextPos = positions[i + 1];\n        const positionBounds = nextPos ? nextPos.x : containerRect.width;\n        if (panes.findIndex(p => p.id === pos.elementId) !== -1) {\n          const newWidth = `${positionBounds - pos.x}px`;\n          newWidths[pos.elementId] = newWidth;\n        } else {\n          // other widths remain as numbers for future math (no css unit yet)\n          otherWidths.push(positionBounds - pos.x);\n        }\n      });\n      const panesetIndex = panes.findIndex(p => p.isPaneset);\n      if (panesetIndex !== -1) {\n        // sum the other widths as a paneset width...\n        const paneSetWidth = otherWidths.reduce((sum, w) => sum + w, 0);\n        const panesetId = panes[panesetIndex].id;\n        newWidths[panesetId] = paneSetWidth;\n        panes[panesetIndex].handlePaneResize({\n          positions,\n          containerRect,\n          ...rest\n        });\n      }\n      this.resizePanes(panes, newWidths);\n      this.updateLayoutCache(newWidths, \'resize\');\n    };\n    let initStyle = {};\n    // Set fixed width only for panes with the counted value\n    if (this.props.defaultWidth !== \'fill\') {\n      initStyle = {\n        flex: `0 0 ${this.props.defaultWidth}`\n      };\n    }\n    this.state = {\n      paneManager: {\n        handleClose: this.handleClose,\n        registerPane: this.registerPane,\n        removePane: this.removePane,\n        getContainer: this.getContainer,\n        getTopmostContainer: this.getTopmostContainer\n      },\n      panes: [],\n      // layoutCache must not be null, but initialLayouts may come in that way,\n      // e.g. if the calling component looks for a cached value but doesn\'t\n      // find one then initialLayouts will be present but null.\n      layoutCache: props.initialLayouts ?? [],\n      style: initStyle,\n      changeType: \'init\' // eslint-disable-line react/no-unused-state\n    };\n    this.container = /*#__PURE__*/react.createRef();\n    this.resizeContainer = /*#__PURE__*/react.createRef();\n    this.id = props.id || (0,lodash.uniqueId)(\'paneset-\');\n    this.widths = [];\n    this.interval = null;\n    this._isMounted = false;\n  }\n  componentDidMount() {\n    if (!this.props.isRoot) {\n      if (this.props.paneset) {\n        // register with parent paneset if it exists\n        this.props.paneset.registerPane({\n          id: this.id,\n          setStyle: this.setStyle,\n          getChildInfo: this.getChildInfo,\n          isThisMounted: this.isThisMounted,\n          isPaneset: true,\n          transition: \'none\',\n          doTransition: false,\n          getRef: this.getRef,\n          getInstance: this.getInstance,\n          handlePaneResize: this.handlePaneResize,\n          getChildPanesTotalWidth: this.getChildPanesTotalWidth\n        });\n      }\n    }\n    this._isMounted = true;\n    this.resizeHandler = window.addEventListener(\'resize\', (0,lodash.debounce)(this.handleWindowResize, 50));\n    this.previousContainerWidth = this.container.current?.getBoundingClientRect().width;\n  }\n  componentWillUnmount() {\n    this._isMounted = false;\n    window.removeEventListener(\'resize\', this.resizeHandler);\n    if (this.widthsRAF) {\n      cancelAnimationFrame(this.widthsRAF);\n      this.widthsRAF = null;\n    }\n    if (this.resizeNestedTO) {\n      clearTimeout(this.resizeNestedTO);\n      this.resizeNestedTO = null;\n    }\n    if (this.transitionCallbackTO) {\n      clearTimeout(this.transitionCallbackTO);\n      this.transitionCallbackTO = null;\n    }\n    if (this.interval) {\n      clearTimeout(this.interval);\n      this.interval = null;\n    }\n    if (!this.props.isRoot && this.props.paneset) {\n      this.props.paneset.removePane(false);\n    }\n  }\n  render() {\n    const {\n      id,\n      children,\n      paneset,\n      isRoot\n    } = this.props;\n\n    // pull any data-test-* props into a spreadable object\n    const dataProps = (0,lodash.pickBy)(this.props, (val, key) => /^data-test/.test(key));\n    return /*#__PURE__*/(0,jsx_runtime.jsx)(PanesetContext/* PanesetContext */.U.Provider, {\n      value: this.state.paneManager,\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(Paneset_PaneResizeContainer, {\n        isRoot: isRoot || !paneset,\n        parentElement: this.container?.current,\n        onElementResize: this.handlePaneResize,\n        resizeContainerRef: this.resizeContainer,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: this.getClassName(),\n          id: id,\n          style: this.state.style,\n          ref: this.container,\n          ...dataProps,\n          children: children\n        })\n      })\n    });\n  }\n}\nPaneset_Paneset_Paneset.propTypes = {\n  // panes and other things that render panes..\n  children: (prop_types_default()).node,\n  // if necessary, Paneset can be assigned a percentage width.\n  defaultWidth: (prop_types_default()).string,\n  // id attribute applied to outer <div>.\n  id: (prop_types_default()).string,\n  // used to initialize Layout Cache of paneset widths\n  initialLayouts: prop_types_default().arrayOf((prop_types_default()).object),\n  // this paneset will not report itself to an ascendent paneset\n  isRoot: (prop_types_default()).bool,\n  // applies styling to properly nest the paneset\n  nested: (prop_types_default()).bool,\n  // callback for overriding layout from the application level\n  onLayout: (prop_types_default()).func,\n  // callback when panes are resized by the user.\n  onResize: (prop_types_default()).func,\n  // the parent paneset of the current paneset\n  paneset: prop_types_default().shape({\n    getTopmostContainer: (prop_types_default()).func,\n    handleClose: (prop_types_default()).func,\n    registerPane: (prop_types_default()).func,\n    removePane: (prop_types_default()).func\n  }),\n  // set if the height of the paneset needs to be controlled.\n  static: (prop_types_default()).bool\n};\nPaneset_Paneset_Paneset.displayName = "Paneset";\nPaneset_Paneset_Paneset.defaultProps = defaultProps;\n/* harmony default export */ const lib_Paneset_Paneset = ((0,PanesetContext/* withPaneset */.b)(Paneset_Paneset_Paneset));\n;\nPaneset_Paneset_Paneset.__docgenInfo = {\n  "description": "",\n  "methods": [{\n    "name": "resizeToContainer",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "resizeNestedPanesets",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "getChildPanesTotalWidth",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "panesList",\n      "optional": true,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "handleWindowResize",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "isThisMounted",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "getContainer",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "getTopmostContainer",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "getClassName",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "setStyle",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "resizePanes",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "panes",\n      "optional": false,\n      "type": null\n    }, {\n      "name": "widths",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "removePane",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "shouldResize",\n      "optional": true,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "registerPane",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "paneObject",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "resizeCachedSizesToFit",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "layoutIndex",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "calcWidthsAndResize",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "changeType",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "transitionStart",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "pane",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "transitionEnd",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "pane",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "isRegistered",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "id",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "handleClose",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "id",\n      "optional": false,\n      "type": null\n    }, {\n      "name": "callback",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "calcWidths",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "panes",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "getRef",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "getInstance",\n    "docblock": null,\n    "modifiers": [],\n    "params": [],\n    "returns": null\n  }, {\n    "name": "cachedLayoutIndex",\n    "docblock": "cachedLayoutIndex\\nSearch state.layoutCache for an object whose keys exactly match those\\nin the candidate.\\n@param {object} candidate\\n@returns int index in state.layoutCache of the matching cache, or -1",\n    "modifiers": [],\n    "params": [{\n      "name": "candidate",\n      "type": {\n        "name": "object"\n      },\n      "optional": false\n    }],\n    "returns": {\n      "description": "int index in state.layoutCache of the matching cache, or -1"\n    },\n    "description": "cachedLayoutIndex\\nSearch state.layoutCache for an object whose keys exactly match those\\nin the candidate."\n  }, {\n    "name": "updateLayoutCache",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "layoutMap",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }, {\n    "name": "handlePaneResize",\n    "docblock": null,\n    "modifiers": [],\n    "params": [{\n      "name": "{ positions, containerRect, ...rest }",\n      "optional": false,\n      "type": null\n    }],\n    "returns": null\n  }],\n  "displayName": "Paneset",\n  "props": {\n    "defaultWidth": {\n      "defaultValue": {\n        "value": "\'fill\'",\n        "computed": false\n      },\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "onLayout": {\n      "defaultValue": {\n        "value": "() => null",\n        "computed": false\n      },\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "initialLayouts": {\n      "defaultValue": {\n        "value": "[]",\n        "computed": false\n      },\n      "description": "",\n      "type": {\n        "name": "arrayOf",\n        "value": {\n          "name": "object"\n        }\n      },\n      "required": false\n    },\n    "children": {\n      "description": "",\n      "type": {\n        "name": "node"\n      },\n      "required": false\n    },\n    "id": {\n      "description": "",\n      "type": {\n        "name": "string"\n      },\n      "required": false\n    },\n    "isRoot": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "nested": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    },\n    "onResize": {\n      "description": "",\n      "type": {\n        "name": "func"\n      },\n      "required": false\n    },\n    "paneset": {\n      "description": "",\n      "type": {\n        "name": "shape",\n        "value": {\n          "getTopmostContainer": {\n            "name": "func",\n            "required": false\n          },\n          "handleClose": {\n            "name": "func",\n            "required": false\n          },\n          "registerPane": {\n            "name": "func",\n            "required": false\n          },\n          "removePane": {\n            "name": "func",\n            "required": false\n          }\n        }\n      },\n      "required": false\n    },\n    "static": {\n      "description": "",\n      "type": {\n        "name": "bool"\n      },\n      "required": false\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvUGFuZXNldC9QYW5lc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZvbGlvL3N0cmlwZXMtY29tcG9uZW50cy8uL2xpYi9QYW5lc2V0L2luc2VydEJ5Q2xpZW50UmVjdC5qcz9mNDkwIiwid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi9saWIvUGFuZXNldC9QYW5lc2V0LmNzcz9lZTBhIiwid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi9saWIvUGFuZXNldC9QYW5lUmVzaXplLmNzcz8zMjQ0Iiwid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi9saWIvUGFuZXNldC9QYW5lUmVzaXplSGFuZGxlLmpzPzU5MzciLCJ3ZWJwYWNrOi8vQGZvbGlvL3N0cmlwZXMtY29tcG9uZW50cy8uL2xpYi9QYW5lc2V0L1BhbmVSZXNpemVDdXJzb3IuanM/MTA5ZiIsIndlYnBhY2s6Ly9AZm9saW8vc3RyaXBlcy1jb21wb25lbnRzLy4vbGliL1BhbmVzZXQvUGFuZVJlc2l6ZUNvbnRhaW5lci5qcz82YTlkIiwid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi9saWIvUGFuZXNldC9QYW5lc2V0LmpzPzRkYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogaW5zZXJ0IGJ5IGNsaWVudFJlY3QgKi9cbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5leHBvcnQgZGVmYXVsdCAocHJldkFycmF5LCBuZXdJdGVtKSA9PiB7XG4gIGxldCBuZXh0SW5kZXggPSAtMTtcbiAgaWYgKG5ld0l0ZW0uZ2V0UmVmKCkuY3VycmVudCkge1xuICAgIGNvbnN0IG5ld0NsaWVudFJlY3QgPSBuZXdJdGVtLmdldFJlZigpLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbmV4dEluZGV4ID0gcHJldkFycmF5LmZpbmRJbmRleChwID0+IHtcbiAgICAgIHJldHVybiBwLmdldFJlZigpLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG5ld0NsaWVudFJlY3QubGVmdDtcbiAgICB9KTtcbiAgfVxuICBsZXQgbmV3QXJyYXk7XG4gIGlmIChuZXh0SW5kZXggPT09IC0xKSB7XG4gICAgbmV3QXJyYXkgPSBbLi4ucHJldkFycmF5LCBuZXdJdGVtXTtcbiAgfSBlbHNlIGlmIChuZXh0SW5kZXggPT09IDApIHtcbiAgICBuZXdBcnJheSA9IFtuZXdJdGVtLCAuLi5wcmV2QXJyYXldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRlbXBQYW5lcyA9IGNsb25lRGVlcChwcmV2QXJyYXkpO1xuICAgIHRlbXBQYW5lcy5zcGxpY2UobmV4dEluZGV4LCAwLCBuZXdJdGVtKTtcbiAgICBuZXdBcnJheSA9IHRlbXBQYW5lcztcbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59OyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS51c2VbMl0hLi9QYW5lc2V0LmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0udXNlWzJdIS4vUGFuZXNldC5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0udXNlWzJdIS4vUGFuZVJlc2l6ZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLnVzZVsyXSEuL1BhbmVSZXNpemUuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBjc3MgZnJvbSAnLi9QYW5lUmVzaXplLmNzcyc7XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgUGFuZVJlc2l6ZUhhbmRsZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChfcmVmLCByZWYpID0+IHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICB4cG9zLFxuICAgIG9uTW91c2VEb3duLFxuICAgIGFjdGl2ZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaGFuZGxlTW91c2VEb3duID0gZSA9PiB7XG4gICAgb25Nb3VzZURvd24oZSwgaWQpO1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL19qc3goXCJkaXZcIiwge1xuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgcmVmOiByZWYsXG4gICAgb25Nb3VzZURvd246IGhhbmRsZU1vdXNlRG93bixcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY3NzLmhhbmRsZSwge1xuICAgICAgW2Nzcy5hY3RpdmVdOiBhY3RpdmVcbiAgICB9KSxcbiAgICBzdHlsZToge1xuICAgICAgbGVmdDogYCR7eHBvc31weGBcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgfSk7XG59KTtcblBhbmVSZXNpemVIYW5kbGUucHJvcFR5cGVzID0ge1xuICBhY3RpdmU6IFByb3BUeXBlcy5ib29sLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25Nb3VzZURvd246IFByb3BUeXBlcy5mdW5jLFxuICB4cG9zOiBQcm9wVHlwZXMubnVtYmVyXG59O1xuUGFuZVJlc2l6ZUhhbmRsZS5kaXNwbGF5TmFtZSA9ICdQYW5lUmVzaXplSGFuZGxlJztcbmV4cG9ydCBkZWZhdWx0IFBhbmVSZXNpemVIYW5kbGU7XG47XG5QYW5lUmVzaXplSGFuZGxlLl9fZG9jZ2VuSW5mbyA9IHtcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICBcIm1ldGhvZHNcIjogW10sXG4gIFwiZGlzcGxheU5hbWVcIjogXCJQYW5lUmVzaXplSGFuZGxlXCIsXG4gIFwicHJvcHNcIjoge1xuICAgIFwiYWN0aXZlXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiaWRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcIm9uTW91c2VEb3duXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImZ1bmNcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwieHBvc1wiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG4gIH1cbn07IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBjc3MgZnJvbSAnLi9QYW5lUmVzaXplLmNzcyc7XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgUGFuZVJlc2l6ZUN1cnNvciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChfcmVmLCByZWYpID0+IHtcbiAgbGV0IHtcbiAgICB2aXNpYmxlLFxuICAgIHhwb3NcbiAgfSA9IF9yZWY7XG4gIC8vIHRoZSBjdXJzb3IgaG92ZXIgYXJpYSBpcyBleHBhbmRlZCBieSBhIHRyYW5zcGFyZW50IGNvbnRhaW5lciBkaXYgdGhhdCdzIDIwcHggd2lkZS5cbiAgLy8gdGhlIGRvdHRlZCBib3JkZXIgaXMgY2VudGVyZWQsIHNvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIGRpdiBpcyBhdCB0aGUgbW91c2UgeCBwb3NpdGlvbiBtaW51c1xuICAvLyAxMHB4LlxuICBjb25zdCBjdXJzb3JIb3ZlckhhbGYgPSAxMDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY3NzLmN1cnNvckhvdmVyLCB7XG4gICAgICBbY3NzLmN1cnNvckFjdGl2ZV06IHZpc2libGVcbiAgICB9KSxcbiAgICBzdHlsZToge1xuICAgICAgbGVmdDogYCR7eHBvcyAtIGN1cnNvckhvdmVySGFsZn1weGBcbiAgICB9LFxuICAgIHJlZjogcmVmLFxuICAgIGhpZGRlbjogIXZpc2libGUsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogY3NzLmN1cnNvcixcbiAgICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgICB9KVxuICB9KTtcbn0pO1xuUGFuZVJlc2l6ZUN1cnNvci5wcm9wVHlwZXMgPSB7XG4gIHZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuICB4cG9zOiBQcm9wVHlwZXMubnVtYmVyXG59O1xuUGFuZVJlc2l6ZUN1cnNvci5kaXNwbGF5TmFtZSA9ICdQYW5lUmVzaXplQ3Vyc29yJztcbmV4cG9ydCBkZWZhdWx0IFBhbmVSZXNpemVDdXJzb3I7XG47XG5QYW5lUmVzaXplQ3Vyc29yLl9fZG9jZ2VuSW5mbyA9IHtcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICBcIm1ldGhvZHNcIjogW10sXG4gIFwiZGlzcGxheU5hbWVcIjogXCJQYW5lUmVzaXplQ3Vyc29yXCIsXG4gIFwicHJvcHNcIjoge1xuICAgIFwidmlzaWJsZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInhwb3NcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuICB9XG59OyIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5pbXBvcnQgaW5zZXJ0QnlDbGllbnRSZWN0IGZyb20gJy4vaW5zZXJ0QnlDbGllbnRSZWN0JztcbmltcG9ydCBQYW5lUmVzaXplSGFuZGxlIGZyb20gJy4vUGFuZVJlc2l6ZUhhbmRsZSc7XG5pbXBvcnQgUGFuZVJlc2l6ZUN1cnNvciBmcm9tICcuL1BhbmVSZXNpemVDdXJzb3InO1xuaW1wb3J0IHsgUmVzaXplUHJvdmlkZXIgfSBmcm9tICcuL1Jlc2l6ZUNvbnRleHQnO1xuaW1wb3J0IGNzcyBmcm9tICcuL1BhbmVSZXNpemUuY3NzJztcbmltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzLCBGcmFnbWVudCBhcyBfRnJhZ21lbnQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmNvbnN0IFBhbmVSZXNpemVDb250YWluZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpc1Jvb3QsXG4gICAgY2hpbGRyZW4sXG4gICAgb25FbGVtZW50UmVzaXplLFxuICAgIHBhcmVudEVsZW1lbnQsXG4gICAgcmVzaXplQ29udGFpbmVyUmVmXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnNvclgsIHNldEN1cnNvclhdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtoYW5kbGVzLCBzZXRIYW5kbGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2FjdGl2ZUhhbmRsZSwgc2V0QWN0aXZlSGFuZGxlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbdXBkYXRlLCBzZXRVcGRhdGVdID0gdXNlU3RhdGUoMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgW2Jsb2NraW5nLCBzZXRCbG9ja2luZ10gPSB1c2VTdGF0ZShudWxsKTtcbiAgbGV0IGNvbnRhaW5lciA9IHVzZVJlZigpO1xuICBpZiAocmVzaXplQ29udGFpbmVyUmVmKSB7XG4gICAgY29udGFpbmVyID0gcmVzaXplQ29udGFpbmVyUmVmO1xuICB9XG4gIGNvbnN0IGhhbmRsZURhdGEgPSB1c2VSZWYoW10pO1xuICBjb25zdCBjb250YWluZXJSZWN0ID0gdXNlUmVmKCk7XG4gIGNvbnN0IGFjdGl2ZVJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBvYnNlcnZlciA9IHVzZVJlZigpO1xuICBjb25zdCBvYnNlcnZlckNhbGxiYWNrID0gdXNlUmVmKG11dGF0aW9uTGlzdCA9PiB7XG4gICAgc2V0QmxvY2tpbmcoY3VyQmxvY2tlciA9PiB7XG4gICAgICBsZXQgYmxvY2tlciA9IGN1ckJsb2NrZXI7XG4gICAgICBtdXRhdGlvbkxpc3QuZm9yRWFjaChtID0+IHtcbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAvLyBjaGVjayBhZ2FpbnN0IGZ1bGwgY29udGFpbmVyIGJvdW5kc1xuICAgICAgICAgIGNvbnN0IGJsb2NraW5nTm9kZSA9IEFycmF5LmZyb20obS5hZGRlZE5vZGVzKS5maW5kKG4gPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Qm94ID0gbj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3Qm94ICYmIGNvbnRhaW5lclJlY3QuY3VycmVudCAmJiBuZXdCb3gubGVmdCA8PSBjb250YWluZXJSZWN0LmN1cnJlbnQubGVmdCAmJiBuZXdCb3gud2lkdGggPj0gY29udGFpbmVyUmVjdC5jdXJyZW50LndpZHRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChibG9ja2luZ05vZGUpIHtcbiAgICAgICAgICAgIGJsb2NrZXIgPSB7XG4gICAgICAgICAgICAgIGlkOiBibG9ja2luZ05vZGUuaWQsXG4gICAgICAgICAgICAgIGNsYXNzOiBibG9ja2luZ05vZGUuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICBzdHlsZTogYmxvY2tpbmdOb2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXJCbG9ja2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmZyb20obS5yZW1vdmVkTm9kZXMpLmZpbmQobiA9PiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgICAgICAgLy8gd2UgbG9vayBmb3IgdGhlIHJlbW92YWwgb2YgYSBub2RlIG1hdGNoaW5nIHRoZSBibG9ja2VyLi4uXG4gICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogbi5pZCxcbiAgICAgICAgICAgICAgICBjbGFzczogbi5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgc3R5bGU6IG4uZ2V0QXR0cmlidXRlKCdzdHlsZScpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKGJsb2NrZXIsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICBibG9ja2VyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJsb2NrZXI7XG4gICAgfSk7XG4gIH0pLmN1cnJlbnQ7XG4gIGNvbnN0IG9uV2luZG93UmVzaXplID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnRhaW5lclJlY3QuY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBzZXRVcGRhdGUodSA9PiB1ICsgMSk7XG4gIH0sIFtdKTtcblxuICAvLyBzZXQgdXAgdGhlIG11dGF0aW9uIG9ic2VydmVyIGZvciBvdmVybGFwcGluZyBlbGVtZW50IG9uY2Ugd2UgZ2V0IGEgdXNhYmxlIHBhcmVudEVsZW1lbnQgcHJvcC5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBjb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIG9ic2VydmVyLmN1cnJlbnQgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvYnNlcnZlckNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIuY3VycmVudC5vYnNlcnZlKHBhcmVudEVsZW1lbnQsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAob2JzZXJ2ZXIuY3VycmVudCkgb2JzZXJ2ZXIuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW3BhcmVudEVsZW1lbnQsIGlzUm9vdCwgb2JzZXJ2ZXJDYWxsYmFja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGlmICghZHJhZ2dpbmcgJiYgYWN0aXZlSGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjdXJyZW50OiBoYW5kbGVMaXN0XG4gICAgICAgIH0gPSBoYW5kbGVEYXRhO1xuICAgICAgICBjb25zdCByZXNpemVkSW5kZXggPSBoYW5kbGVMaXN0LmZpbmRJbmRleChoID0+IGguaWQgPT09IGFjdGl2ZUhhbmRsZS5pZCk7XG4gICAgICAgIGlmIChyZXNpemVkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgaGFuZGxlTGlzdFtyZXNpemVkSW5kZXhdLnggPSBjdXJzb3JYO1xuICAgICAgICAgIG9uRWxlbWVudFJlc2l6ZSh7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IGhhbmRsZUxpc3QsXG4gICAgICAgICAgICBhY3RpdmVIYW5kbGUsXG4gICAgICAgICAgICBjdXJzb3JYLFxuICAgICAgICAgICAgY29udGFpbmVyUmVjdDogY29udGFpbmVyUmVjdC5jdXJyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QWN0aXZlSGFuZGxlKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2RyYWdnaW5nLCBhY3RpdmVIYW5kbGUsIG9uRWxlbWVudFJlc2l6ZSwgY3Vyc29yWCwgaXNSb290XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyLmN1cnJlbnQpIG9ic2VydmVyLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB1cGRhdGVDdXJzb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGNvbnN0IHVwZGF0ZUN1cnNvciA9IHVzZUNhbGxiYWNrKGUgPT4ge1xuICAgIGlmIChjb250YWluZXJSZWN0LmN1cnJlbnQpIHtcbiAgICAgIGxldCBuZXh0WCA9IGUuY2xpZW50WCAtIGNvbnRhaW5lclJlY3QuY3VycmVudC5sZWZ0O1xuICAgICAgY29uc3QgaGRhdGEgPSBoYW5kbGVEYXRhLmN1cnJlbnQ7XG4gICAgICBjb25zdCBoYW5kbGVPZmZzZXQgPSAyMDsgLy8gc29tZSBtYXJnaW4gb24gdGhlIGJvdW5kcyBvZiBhIHJlc2l6ZSBoYW5kbGVcbiAgICAgIGNvbnN0IHByZXZIYW5kbGUgPSBoZGF0YVthY3RpdmVSZWYuY3VycmVudCAtIDFdIHx8IHtcbiAgICAgICAgeDogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG5leHRIYW5kbGUgPSBoZGF0YVthY3RpdmVSZWYuY3VycmVudCArIDFdIHx8IHtcbiAgICAgICAgeDogY29udGFpbmVyUmVjdC5jdXJyZW50LndpZHRoXG4gICAgICB9O1xuICAgICAgaWYgKG5leHRYIDwgcHJldkhhbmRsZS54ICsgaGFuZGxlT2Zmc2V0KSB7XG4gICAgICAgIG5leHRYID0gcHJldkhhbmRsZS54ICsgaGFuZGxlT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChuZXh0WCA+IG5leHRIYW5kbGUueCAtIGhhbmRsZU9mZnNldCkge1xuICAgICAgICBuZXh0WCA9IG5leHRIYW5kbGUueCAtIGhhbmRsZU9mZnNldDtcbiAgICAgIH1cbiAgICAgIHNldEN1cnNvclgobmV4dFgpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBoYW5kbGVNb3VzZVVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHVwZGF0ZUN1cnNvcik7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudXNlclNlbGVjdCA9ICdhdXRvJztcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnYXV0byc7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tc1VzZXJTZWxlY3QgPSAnYXV0byc7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tc1VzZXJTZWxlY3QgPSAnYXV0byc7XG4gICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICB9LCBbdXBkYXRlQ3Vyc29yXSk7XG4gIGNvbnN0IGhhbmRsZUhhbmRsZU1vdXNlRG93biA9IHVzZUNhbGxiYWNrKChlLCBpZCkgPT4ge1xuICAgIHNldEN1cnNvclgoZS5jbGllbnRYKTtcbiAgICBzZXREcmFnZ2luZyh0cnVlKTtcbiAgICBjb25zdCBoYW5kbGVJbmRleCA9IGhhbmRsZXMuZmluZEluZGV4KGggPT4gaC5pZCA9PT0gaWQpO1xuICAgIGNvbnN0IGhhbmRsZURhdGFJbmRleCA9IGhhbmRsZURhdGEuY3VycmVudC5maW5kSW5kZXgoaCA9PiBoLmlkID09PSBpZCk7XG4gICAgc2V0QWN0aXZlSGFuZGxlKGhhbmRsZXNbaGFuZGxlSW5kZXhdKTtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IGhhbmRsZURhdGFJbmRleDtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB1cGRhdGVDdXJzb3IpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubXNVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubW96VXNlclNlbGVjdCA9ICdub25lJztcbiAgfSwgW2hhbmRsZU1vdXNlVXAsIGhhbmRsZXMsIHVwZGF0ZUN1cnNvcl0pO1xuICBjb25zdCByZWdpc3RlckhhbmRsZSA9IF9yZWYyID0+IHtcbiAgICBsZXQge1xuICAgICAgaWQsXG4gICAgICBlbGVtZW50SWQsXG4gICAgICBnZXRSZWZcbiAgICB9ID0gX3JlZjI7XG4gICAgc2V0SGFuZGxlcyhjdXJIYW5kbGVzID0+IHtcbiAgICAgIGlmIChjdXJIYW5kbGVzLmZpbmRJbmRleChoID0+IGguaWQgPT09IGlkKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydEJ5Q2xpZW50UmVjdChjdXJIYW5kbGVzLCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZWxlbWVudElkLFxuICAgICAgICAgIGdldFJlZlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJIYW5kbGVzO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCByZW1vdmVIYW5kbGUgPSBpZCA9PiB7XG4gICAgc2V0SGFuZGxlcyhjdXJIYW5kbGVzID0+IHtcbiAgICAgIGNvbnN0IGluZGV4VG9SZW1vdmUgPSBjdXJIYW5kbGVzLmZpbmRJbmRleChoID0+IGguaWQgPT09IGlkKTtcbiAgICAgIGlmIChpbmRleFRvUmVtb3ZlICE9PSAtMSkge1xuICAgICAgICBjb25zdCB0ZW1wID0gY2xvbmVEZWVwKGN1ckhhbmRsZXMpO1xuICAgICAgICB0ZW1wLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKTtcbiAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VySGFuZGxlcztcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgcmVuZGVySGFuZGxlcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBoYW5kbGVEYXRhLmN1cnJlbnQgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVFbGVtZW50cyA9IGhhbmRsZXMubWFwKGggPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGguZ2V0UmVmKCk/LmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA9PT0gMCkge1xuICAgICAgICAgIGhhbmRsZURhdGEuY3VycmVudC5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBoLmlkLFxuICAgICAgICAgICAgZWxlbWVudElkOiBoLmVsZW1lbnRJZCxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiA1MFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRhaW5lclJlY3QuY3VycmVudCkge1xuICAgICAgICAgIGNvbnRhaW5lclJlY3QuY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMZWZ0ID0gcmVjdC5sZWZ0IC0gKGNvbnRhaW5lclJlY3QuY3VycmVudCA/IGNvbnRhaW5lclJlY3QuY3VycmVudC5sZWZ0IDogMCk7XG4gICAgICAgIGNvbnN0IHRvcCA9IHJlY3QudG9wIC0gKGNvbnRhaW5lclJlY3QuY3VycmVudCA/IGNvbnRhaW5lclJlY3QuY3VycmVudC50b3AgOiAwKTtcbiAgICAgICAgaGFuZGxlRGF0YS5jdXJyZW50LnB1c2goe1xuICAgICAgICAgIGlkOiBoLmlkLFxuICAgICAgICAgIGVsZW1lbnRJZDogaC5lbGVtZW50SWQsXG4gICAgICAgICAgeDogbmV3TGVmdCxcbiAgICAgICAgICB5OiB0b3BcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChQYW5lUmVzaXplSGFuZGxlLCB7XG4gICAgICAgICAgaWQ6IGguaWQsXG4gICAgICAgICAgeHBvczogbmV3TGVmdCAtIDMsXG4gICAgICAgICAgYWN0aXZlOiBhY3RpdmVIYW5kbGUgJiYgaC5pZCA9PT0gYWN0aXZlSGFuZGxlLmlkLFxuICAgICAgICAgIG9uTW91c2VEb3duOiBoYW5kbGVIYW5kbGVNb3VzZURvd25cbiAgICAgICAgfSwgaC5pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICByZXR1cm4gaGFuZGxlRWxlbWVudHM7XG4gIH0sIFthY3RpdmVIYW5kbGUsIGhhbmRsZUhhbmRsZU1vdXNlRG93biwgaGFuZGxlc10pO1xuXG4gIC8vIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgYGZvcmNlVXBkYXRlYCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLlxuICBjb25zdCB1cGRhdGVIYW5kbGUgPSAoKSA9PiB7XG4gICAgaWYgKGNvbnRhaW5lclJlY3QuY3VycmVudCkge1xuICAgICAgc2V0VXBkYXRlKHUgPT4gdSArIDEpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3VzcGVuZCA9ICgpID0+IHtcbiAgICBzZXRCbG9ja2luZyh7XG4gICAgICBzZXRCeUxheWVyOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHJlc3VtZSA9ICgpID0+IHtcbiAgICBzZXRCbG9ja2luZyhudWxsKTtcbiAgfTtcbiAgaWYgKGlzUm9vdCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgICBjaGlsZHJlbjogWy8qI19fUFVSRV9fKi9fanN4KFJlc2l6ZVByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgcmVnaXN0ZXJIYW5kbGUsXG4gICAgICAgICAgdXBkYXRlSGFuZGxlLFxuICAgICAgICAgIHJlbW92ZUhhbmRsZSxcbiAgICAgICAgICBzdXNwZW5kLFxuICAgICAgICAgIHJlc3VtZVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovX2pzeHMoXCJkaXZcIiwge1xuICAgICAgICByZWY6IGNvbnRhaW5lcixcbiAgICAgICAgY2xhc3NOYW1lOiBjc3MuY29udGFpbmVyLFxuICAgICAgICBjaGlsZHJlbjogWyFibG9ja2luZyAmJiByZW5kZXJIYW5kbGVzKCksIC8qI19fUFVSRV9fKi9fanN4KFBhbmVSZXNpemVDdXJzb3IsIHtcbiAgICAgICAgICB2aXNpYmxlOiBkcmFnZ2luZyxcbiAgICAgICAgICBhY3RpdmVJZDogYWN0aXZlSGFuZGxlLFxuICAgICAgICAgIHhwb3M6IGN1cnNvclhcbiAgICAgICAgfSldXG4gICAgICB9KV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59O1xuUGFuZVJlc2l6ZUNvbnRhaW5lci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSksIFByb3BUeXBlcy5ub2RlXSksXG4gIGlzUm9vdDogUHJvcFR5cGVzLmJvb2wsXG4gIG9uRWxlbWVudFJlc2l6ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhcmVudEVsZW1lbnQ6IFByb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnQpLFxuICByZXNpemVDb250YWluZXJSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSlcbn07XG5leHBvcnQgZGVmYXVsdCBQYW5lUmVzaXplQ29udGFpbmVyO1xuO1xuUGFuZVJlc2l6ZUNvbnRhaW5lci5fX2RvY2dlbkluZm8gPSB7XG4gIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgXCJtZXRob2RzXCI6IFtdLFxuICBcImRpc3BsYXlOYW1lXCI6IFwiUGFuZVJlc2l6ZUNvbnRhaW5lclwiLFxuICBcInByb3BzXCI6IHtcbiAgICBcImNoaWxkcmVuXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInVuaW9uXCIsXG4gICAgICAgIFwidmFsdWVcIjogW3tcbiAgICAgICAgICBcIm5hbWVcIjogXCJhcnJheU9mXCIsXG4gICAgICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCJcbiAgICAgICAgfV1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImlzUm9vdFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcIm9uRWxlbWVudFJlc2l6ZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInBhcmVudEVsZW1lbnRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwiaW5zdGFuY2VPZlwiLFxuICAgICAgICBcInZhbHVlXCI6IFwiRWxlbWVudFwiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJyZXNpemVDb250YWluZXJSZWZcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwidW5pb25cIixcbiAgICAgICAgXCJ2YWx1ZVwiOiBbe1xuICAgICAgICAgIFwibmFtZVwiOiBcIm9iamVjdFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgICAgfV1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuICB9XG59OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBwaWNrQnksIHVuaXF1ZUlkLCBjbG9uZURlZXAsIGRlYm91bmNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwYXJzZUNTU1VuaXQgZnJvbSAnLi4vLi4vdXRpbC9wYXJzZUNTU1VuaXQnO1xuaW1wb3J0IGluc2VydEJ5Q2xpZW50UmVjdCBmcm9tICcuL2luc2VydEJ5Q2xpZW50UmVjdCc7XG5pbXBvcnQgY3NzIGZyb20gJy4vUGFuZXNldC5jc3MnO1xuaW1wb3J0IFBhbmVSZXNpemVDb250YWluZXIgZnJvbSAnLi9QYW5lUmVzaXplQ29udGFpbmVyJztcbmltcG9ydCB7IHdpdGhQYW5lc2V0LCBQYW5lc2V0Q29udGV4dCB9IGZyb20gJy4vUGFuZXNldENvbnRleHQnO1xuXG4vKiBQYW5lc1xuKiAgUGFuZXNldHMgaG9sZCBwYXNzIGFuIEFQSSBkb3duIHRvIHBhbmVzIHZpYSBSZWFjdCBjb250ZXh0IHRoYXQgcmVnaXN0ZXJzXG4qICB0aGUgcGFuZSBhbmQgYWxsb3dzIFBhbmVzZXQgdG8gdHJhY2sgdGhlIHdpZHRocyBvZiBlYWNoIG1vdW50ZWQgcGFuZVxuKiAgc28gdGhhdCB0aGV5IG1heSBiZSBhcHByb3ByaWF0ZWx5IHJlc2l6ZWQuIGluY3JlYXNpbmcgdGhlIHNpemUgb2Ygb25lIG1ha2VzIGFub3RoZXIgc2hyaW5rLlxuKiAgUGFuZXNldHMgYWxzbyBoYW5kbGUgc2hyaW5raW5nIG9yIGdyb3dpbmcgdGhlIHBhbmVzIGFzIHRoZSB3aW5kb3cgaXMgcmVzaXplZC5cbiovXG5cbi8qIERhdGFmbG93XG4qICBQYW5lLXJlc2l6aW5nOlxuKiAgaGFuZGxlUGFuZVJlc2l6ZSgpIC0+IHJlc2l6ZVBhbmVzKCksIHVwZGF0ZUxheW91dENhY2hlKClcbiogIFdpbmRvdyByZXNpemluZzpcbiogIHJlc2l6ZVRvQ29udGFpbmVyKCkgLT4gdXBkYXRlTGF5b3V0Q2FjaGUoKSwgcmVzaXplUGFuZXMoKVxuKiAgQWRkaW5nIGEgcGFuZTpcbiogIHJlZ2lzdGVyUGFuZSgpIC0+XG4gICAgICBpbnNlcnRCeUNsaWVudFJlY3QoKSwgY2FsY1dpZHRoc0FuZFJlc2l6ZSgpIC0+IHJlc2l6ZUNhY2hlZFNpemVUb0ZpdCgpLCByZXNpemVQYW5lcygpLCB1cGRhdGVMYXlvdXRDYWNoZSgpXG4qL1xuXG4vKiBEYXRhIHNoYXBlczpcbipcbiogIHdpZHRocyAtICh1c2VkIGJ5IGNhbGNXaWR0aHMoKSkgYXJlIGluIHRoZSBzaGFwZSBvZiB7IGlkOiA8c3RyaW5nPiwgZGVmYXVsdFdpZHRoOiA8c3RyaW5nPiB9XG4qXG4qICBsYXlvdXRDYWNoZSAtICAoaGVsZCBieSBzdGF0ZSkgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aGVyZSBrZXlzIGFyZSBpZCdzIGFuZCB2YWx1ZXMgYXJlIENTUy1zdHJpbmdcbiogICAgdmFsdWVzIChlZyAnMzI3cHgnLCAnMjQlJykgaW4gdGhlIHNoYXBlIG9mIHsgPHBhbmVpZCBzdHJpbmc+OiA8d2lkdGggc3RyaW5nPiB9XG4qICAgIGxheW91dENhY2hlIGl0ZW1zIHJlcHJlc2VudCBkaWZmZXJlbnQgY29tYmluYXRpb25zIG9mIHBhbmVzICgxLCAyLCAzLCBuICkgcGFuZXMgYW5kXG4qICAgIGRpY3RhdGUgdGhlIHdpZHRocyB0byBiZSB1c2VkIHdoZW4gdGhhdCBwYXJ0aWN1bGFyIHNldCBvZiBwYW5lcyBtb3VudHMuXG4qICAgIExheW91dENhY2hlIGlzIGhlbGQgYnkgdGhlIHBhbmVzZXQncyBzdGF0ZSB0byBiZSB1c2VkIGFuZCByZS1hcHBsaWVkIHdoZW4gcGFydGljdWxhciBzZXQgb2ZcbiogICAgcGFuZXMgaXMgcmUtbW91bnRlZC4gSW4gdGhlIHBlcnNpc3RlZCBwYW5lc2V0IHNtYXJ0LWNvbXBvbmVudCwgdGhpc1xuKiAgICBjYWNoZSBpcyBzYXZlZCB0byBsb2NhbFN0b3JhZ2UgYW5kIGJyb3VnaHQgYmFjayBpbnRvIHRoZSBjb21wb25lbnQgdmlhIHByb3BzIChzbyBpdCBzdXJ2aXZlcyBzd2l0Y2hpbmcgYXBwcylcbipcbiogIHBhbmUgYXJyYXkgLSB0aGUgcGFuZXMgKG9uIG1vdW50KSByZWdpc3RlciBhIGNvbGxlY3Rpb24gb2YgZGF0YSBhbmQgZnVuY3Rpb25zIHRvIHN0YXRlIGZvciBlYXN5IGFjY2VzcyB3aXRoaW5cbiogICAgdGhpcyBjb21wb25lbnRcbiogICAgaW5jbHVkaW5nIHRoZWlyIGRlZmF1bHRXaWR0aCBwcm9wLCBhIGZ1bmN0aW9uIHRvIGdldCB0aGVpciBvdXRlciBlbGVtZW50LCBhbmQgdGhlaXIgc2V0U3R5bGUgbWV0aG9kLlxuKi9cbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGRlZmF1bHRXaWR0aDogJ2ZpbGwnLFxuICBvbkxheW91dDogKCkgPT4gbnVsbCxcbiAgaW5pdGlhbExheW91dHM6IFtdXG59O1xuZnVuY3Rpb24gZ2V0TmV3UGFuZXdpZHRoT2JqZWN0KGtleSwgQ1NTdmFsdWUsIHByb3BvcnRpb25hbENoYW5nZSkge1xuICBjb25zdCB1bml0ID0gcGFyc2VDU1NVbml0KENTU3ZhbHVlKTtcbiAgbGV0IG5ld1dpZHRoID0gQ1NTdmFsdWU7XG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ3BlcmNlbnQnOlxuICAgICAgbmV3V2lkdGggPSBwYXJzZUZsb2F0KENTU3ZhbHVlLCAxMCkgKiBwcm9wb3J0aW9uYWxDaGFuZ2U7XG4gICAgICBuZXdXaWR0aCA9IGAke25ld1dpZHRofSVgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndncnOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHgnOlxuICAgICAgbmV3V2lkdGggPSBNYXRoLmNlaWwocGFyc2VJbnQoQ1NTdmFsdWUsIDEwKSAqIHByb3BvcnRpb25hbENoYW5nZSk7XG4gICAgICBuZXdXaWR0aCA9IGAke25ld1dpZHRofXB4YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VtJzpcbiAgICAgIG5ld1dpZHRoID0gTWF0aC5jZWlsKHBhcnNlSW50KENTU3ZhbHVlLCAxMCkgKiAxNCAqIHByb3BvcnRpb25hbENoYW5nZSk7XG4gICAgICBuZXdXaWR0aCA9IGAke25ld1dpZHRoIC8gMTR9ZW1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVtJzpcbiAgICAgIG5ld1dpZHRoID0gTWF0aC5jZWlsKHBhcnNlSW50KENTU3ZhbHVlLCAxMCkgKiAxNCAqIHByb3BvcnRpb25hbENoYW5nZSk7XG4gICAgICBuZXdXaWR0aCA9IGAke25ld1dpZHRoIC8gMTR9cmVtYDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkOiBrZXksXG4gICAgZGVmYXVsdFdpZHRoOiBuZXdXaWR0aFxuICB9O1xufVxuZnVuY3Rpb24gaXNVbml0UGl4ZWxCYXNlZChjc3NTdHJpbmcpIHtcbiAgY29uc3QgcGl4ZWxWYWx1ZXMgPSBbJ3B4JywgJ2VtJywgJ3JlbSddO1xuICByZXR1cm4gcGl4ZWxWYWx1ZXMuc29tZShwdiA9PiBjc3NTdHJpbmcuaW5jbHVkZXMocHYpKTtcbn1cbmNsYXNzIFBhbmVzZXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgX3RoaXMgPSB0aGlzO1xuICAgIC8vIHJlc2l6ZVRvQ29udGFpbmVyIC0gY2FsbGVkIHdoZW4gdGhlIHdpbmRvdyBpcyByZXNpemVkLlxuICAgIC8vIFJlc2l6ZXMgcGFuZXMgdG8gZml0IHRoZSB3aW5kb3cgd2lkdGggKm9yIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmluZyBwYW5lc2V0KGlmIG5lc3RlZC4pXG4gICAgLy8gY29tcGFyZXMgdGhlIGN1cnJlbnQgd2luZG93IC8gY29udGFpbmVyIHdpZHRoIHRvIHRoZSB0b3RhbCB3aWR0aCBvZiB0aGVcbiAgICAvLyBwYW5lIGVsZW1lbnRzIGFuZCByZXNpemVzIHRoZW0gdmlhIGEgbXVsdGlwbGllci5cbiAgICAvLyBpZiB0aGUgd2luZG93IGlzIHJlc2l6ZWQgdG8gdHdpY2UgYXMgbGFyZ2UsIHBhbmVzIGFyZSByZXNpemVkIHRvIHR3aWNlIHRoZSBwaXhlbCBzaXplLlxuICAgIHRoaXMucmVzaXplVG9Db250YWluZXIgPSAoKSA9PiB7XG4gICAgICAvLyBubyBzZW5zZSBkb2luZyBhbGwgdGhpcyBtYXRoIGlmIHRoZSBjb21wb25lbnQgaGFzIGFscmVhZHkgdW5tb3VudGVkXG4gICAgICBpZiAoIXRoaXMuX2lzTW91bnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHBpY2sgdGhlIGFjdGl2ZSBsYXlvdXQgY2FjaGUgZW50cnkgLSB3aWxsIGNvbnRhaW4gbWF0Y2hpbmcgaWQncyBhbmQgbnVtYmVyIG9mIGlkJ3MuLi5cbiAgICAgIGNvbnN0IHBhbmVJZHMgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGUucGFuZXMuZm9yRWFjaChwID0+IHBhbmVJZHMucHVzaChwLmlkKSk7XG4gICAgICBsZXQgY3VycmVudFdpZHRoO1xuICAgICAgaWYgKCF0aGlzLnByb3BzLnBhbmVzZXQpIHtcbiAgICAgICAgY3VycmVudFdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50V2lkdGggPSB0aGlzLmNvbnRhaW5lci5jdXJyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIH1cbiAgICAgIGxldCB0b3RhbFdpZHRoID0gMDtcblxuICAgICAgLy8gY2hlY2sgZm9yIGNhY2hlZCBsYXlvdXQgY292ZXJzIGluc3RhbmNlcyB3aGVyZSB0aGUga2V5cyBvZiB0aGUgb2JqZWN0IG1heSBub3QgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXNcbiAgICAgIC8vIHRoZSBcInBhbmVJZFwiIGFycmF5LlxuICAgICAgY29uc3QgbWF0Y2hpbmdDYWNoZUluZGV4ID0gdGhpcy5zdGF0ZS5sYXlvdXRDYWNoZT8uZmluZEluZGV4KGMgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZUlkcyA9IE9iamVjdC5rZXlzKGMpO1xuICAgICAgICBpZiAoY2FjaGVJZHMubGVuZ3RoICE9PSBwYW5lSWRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gY2FjaGVJZHMuZXZlcnkoaWQgPT4gcGFuZUlkcy5pbmNsdWRlcyhpZCkpO1xuICAgICAgfSkgPz8gLTE7XG4gICAgICBpZiAobWF0Y2hpbmdDYWNoZUluZGV4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0xDYWNoZSA9IHRoaXMuc3RhdGUubGF5b3V0Q2FjaGVbbWF0Y2hpbmdDYWNoZUluZGV4XTtcbiAgICAgICAgLy8gc2V0IGFycmF5IHVwIHdpdGggZGVmYXVsdFdpZHRoIGFuZCBpZC4uLnBhc3MgdG8gY2FsYyB3aWR0aHMuXG4gICAgICAgIGNvbnN0IHRlbXBQYW5lc0xpc3QgPSBbXTtcbiAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCkge1xuICAgICAgICAgIC8vIGdldCBhbiBhY3R1YWwgd2lkdGggb2YgdGhlIHBhbmVzZXQuLi5cbiAgICAgICAgICB0b3RhbFdpZHRoID0gdGhpcy5nZXRDaGlsZFBhbmVzVG90YWxXaWR0aCgpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIHRvdGFsV2lkdGggaXMgMCwgcGFuZXMgaGF2ZW4ndCBiZWVuIHNpemVkIHlldCwgc28gZ28gYWhlYWQgYW5kIGNhbGNXaWR0aHMvcmVzaXplLi4uXG4gICAgICAgICAgaWYgKHRvdGFsV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRocyA9IHRoaXMuY2FsY1dpZHRocyh0aGlzLnN0YXRlLnBhbmVzKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGFuZXModGhpcy5zdGF0ZS5wYW5lcywgd2lkdGhzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjaGVjayBhY3R1YWwgd2lkdGggYWdhaW5zdCB3aWR0aCBvZiBjb250YWluaW5nIGVsZW1lbnQuLi4gdGhpcyBwcmV2ZW50cyBjb250aW51ZWQgcHJvcG9ydGlvbmFsIHJlc2l6ZXMuXG4gICAgICAgICAgaWYgKE1hdGguZmxvb3IodG90YWxXaWR0aCkgIT09IGN1cnJlbnRXaWR0aCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcG9ydGlvbmFsQ2hhbmdlID0gY3VycmVudFdpZHRoIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBtYXRjaGluZ0xDYWNoZSkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hdGNoaW5nTENhY2hlLCBwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BPID0gZ2V0TmV3UGFuZXdpZHRoT2JqZWN0KHAsIG1hdGNoaW5nTENhY2hlW3BdLCBwcm9wb3J0aW9uYWxDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHRlbXBQYW5lc0xpc3QucHVzaChuZXdQTyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY3VyciA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBDYWNoZSA9IGNsb25lRGVlcChjdXJyLmxheW91dENhY2hlKTtcbiAgICAgICAgICAgICAgdGVtcENhY2hlLnNwbGljZShtYXRjaGluZ0NhY2hlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxheW91dENhY2hlOiB0ZW1wQ2FjaGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgLy8gLy8gYWRqdXN0IHRoZSBsYXlvdXQgY2FjaGUgcmVsYXRpdmUgdG8gdGhlIG5ldyBjbGllbnQgcmVjdCBzaXplXG4gICAgICAgICAgICAgIC8vIC8vIHNpemUgcGFuZXMgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRocyA9IHRoaXMuY2FsY1dpZHRocyh0ZW1wUGFuZXNMaXN0KTtcblxuICAgICAgICAgICAgICAvLyBiZSBzdXJlIGFuZCB1cGRhdGUgdGhlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGlzIG9uIHRoZSBuZXh0IHJlc2l6ZS4uLlxuICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29udGFpbmVyV2lkdGggPSBjdXJyZW50V2lkdGg7XG4gICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVR5cGUgPSAnd2luZG93UmVzaXplJztcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXRDYWNoZShuZXdXaWR0aHMsIGNoYW5nZVR5cGUpO1xuICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVBhbmVzKHRoaXMuc3RhdGUucGFuZXMsIG5ld1dpZHRocyk7XG4gICAgICAgICAgICAgIHRoaXMucmVzaXplTmVzdGVkVE8gPSBzZXRUaW1lb3V0KHRoaXMucmVzaXplTmVzdGVkUGFuZXNldHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIHdpZHRoIG9mIHRoZSBvdXRzaWRlIGNvbnRhaW5lcnMgZmlsbHMgdGhlIHdpbmRvdyAoY3VycmVudFdpZHRoID09PSB0b3RhbFdpZHRoKSB0aGUgcGFuZXMgd2l0aGluXG4gICAgICAgICAgICAvLyBuZXN0ZWQgcGFuZXNldHMgbWF5IG5lZWQgcmVzaXppbmcuLi5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBjaGFuZ2VUeXBlOiAnd2luZG93UmVzaXplTmVzdGVkUGFuZXNldFBhbmVzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tdW51c2VkLXN0YXRlXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVzaXplTmVzdGVkVE8gPSBzZXRUaW1lb3V0KHRoaXMucmVzaXplTmVzdGVkUGFuZXNldHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wQ2FjaGUgPSB7fTtcbiAgICAgICAgY29uc3QgdGVtcFBhbmVzTGlzdCA9IFtdO1xuICAgICAgICB0b3RhbFdpZHRoID0gdGhpcy5nZXRDaGlsZFBhbmVzVG90YWxXaWR0aCgpO1xuXG4gICAgICAgIC8vIGlmIHBhbmVzIGRvbid0IGZpbGwgdGhlIGNvbnRhaW5lciwgcmVzaXplIHRoZW0gYXMgd2VsbCBhcyBuZXN0ZWQgcGFuZXNldHMuXG4gICAgICAgIGlmIChNYXRoLmZsb29yKHRvdGFsV2lkdGgpICE9PSBjdXJyZW50V2lkdGgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wb3J0aW9uYWxDaGFuZ2UgPSBjdXJyZW50V2lkdGggLyB0b3RhbFdpZHRoO1xuICAgICAgICAgIGZvciAoY29uc3QgcCBpbiB0ZW1wQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGVtcENhY2hlLCBwKSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdQTyA9IGdldE5ld1BhbmV3aWR0aE9iamVjdChwLCB0ZW1wQ2FjaGVbcF0sIHByb3BvcnRpb25hbENoYW5nZSk7XG4gICAgICAgICAgICAgIHRlbXBQYW5lc0xpc3QucHVzaChuZXdQTyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld1dpZHRocyA9IHRoaXMuY2FsY1dpZHRocyh0ZW1wUGFuZXNMaXN0KTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNoYW5nZVR5cGU6ICd3aW5kb3dSZXNpemVVbmNhY2hlZCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tdW51c2VkLXN0YXRlXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVQYW5lcyh0aGlzLnN0YXRlLnBhbmVzLCBuZXdXaWR0aHMpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVOZXN0ZWRUTyA9IHNldFRpbWVvdXQodGhpcy5yZXNpemVOZXN0ZWRQYW5lc2V0cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXZlbiBpZiB0aGUgd2lkdGggb2YgdGhlIG91dHNpZGUgY29udGFpbmVycyBmaWxscyB0aGUgd2luZG93IChjdXJyZW50V2lkdGggPT09IHRvdGFsV2lkdGgpIHRoZSBwYW5lcyB3aXRoaW5cbiAgICAgICAgICAvLyBuZXN0ZWQgcGFuZXNldHMgbWF5IG5lZWQgcmVzaXppbmcuLi5cbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNoYW5nZVR5cGU6ICd3aW5kb3dSZXNpemVOZXN0ZWRVbmNhY2hlZCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tdW51c2VkLXN0YXRlXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVOZXN0ZWRUTyA9IHNldFRpbWVvdXQodGhpcy5yZXNpemVOZXN0ZWRQYW5lc2V0cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplTmVzdGVkUGFuZXNldHMgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucGFuZXMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICBpZiAocC5pc1BhbmVzZXQpIHtcbiAgICAgICAgICAgIHAuZ2V0SW5zdGFuY2UoKS5yZXNpemVUb0NvbnRhaW5lcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZU5lc3RlZFRPID0gbnVsbDtcbiAgICB9O1xuICAgIC8vIHJldHVybiB0b3RhbCB3aWR0aCBvZiBjaGlsZCBwYW5lcyBvZiB0aGlzIGFuZCBhbnkgbmVzdGVkIHBhbmVzZXRzLlxuICAgIHRoaXMuZ2V0Q2hpbGRQYW5lc1RvdGFsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgcGFuZXNMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfdGhpcy5zdGF0ZS5wYW5lcztcbiAgICAgIGxldCB0b3RhbFdpZHRoID0gMDtcbiAgICAgIHBhbmVzTGlzdC5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBpZiAocC5pc1BhbmVzZXQpIHtcbiAgICAgICAgICB0b3RhbFdpZHRoICs9IHAuZ2V0Q2hpbGRQYW5lc1RvdGFsV2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbGVtID0gcC5nZXRSZWYoKTtcbiAgICAgICAgICBpZiAoZWxlbS5jdXJyZW50KSB7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IGVsZW0uY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNSb290LFxuICAgICAgICBwYW5lc2V0XG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmIChpc1Jvb3QgfHwgIXBhbmVzZXQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVUb0NvbnRhaW5lcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pc1RoaXNNb3VudGVkID0gKCkgPT4gdGhpcy5faXNNb3VudGVkO1xuICAgIHRoaXMuZ2V0Q29udGFpbmVyID0gKCkgPT4gdGhpcy5jb250YWluZXIuY3VycmVudDtcbiAgICB0aGlzLmdldFRvcG1vc3RDb250YWluZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhbmVzZXQsXG4gICAgICAgIGlzUm9vdFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIWlzUm9vdCAmJiBwYW5lc2V0KSB7XG4gICAgICAgIHJldHVybiBwYW5lc2V0LmdldFRvcG1vc3RDb250YWluZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgIH07XG4gICAgdGhpcy5nZXRDbGFzc05hbWUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5lc3RlZCxcbiAgICAgICAgc3RhdGljOiBwcm9wc1N0YXRpY1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lcyhbe1xuICAgICAgICBbY3NzLm5lc3RlZF06IG5lc3RlZFxuICAgICAgfSwge1xuICAgICAgICBbY3NzLnN0YXRpY106IHByb3BzU3RhdGljXG4gICAgICB9LCBjc3MucGFuZXNldF0pO1xuICAgIH07XG4gICAgdGhpcy5zZXRTdHlsZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVGhpc01vdW50ZWQoKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGFuZXNldCxcbiAgICAgICAgICBpc1Jvb3RcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgLy8gZm9yIG5lc3RlZCwgbm9uLXJvb3QgcGFuZXNldHMsIHdlIHJlc2l6ZSB0aGVpciBlbGVtZW50IHRvIHRoZSBlZGdlIG9mIHRoZSBzY3JlZW4uXG4gICAgICAgIC8vIHRoaXMgcmVzb2x2ZXMgYSBjcm9wcGluZyBiZWhhdmlvciAoaW1wZXR1cyBmb3IgU1RDT00tOTUzKSBhbmQgYWxsb3dzXG4gICAgICAgIC8vIHBhbmVzZXQgdG8gYWNjdXJhdGVseSByZXNpemUgaXRzIGNoaWxkcmVuIChvdmVyZmxvdzogaGlkZGVuKVxuICAgICAgICBpZiAocGFuZXNldCAmJiAhaXNSb290KSB7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdGhpcy5jb250YWluZXIuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lckJvdW5kcy5yaWdodCA8IHdpbmRvdy5vZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShjdXJTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0XG4gICAgICAgICAgICAgIH0gPSBjb250YWluZXJCb3VuZHM7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1N0eWxlID0ge1xuICAgICAgICAgICAgICAgIGZsZXg6IGAwIDAgJHtyaWdodCAtIGxlZnR9cHhgXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVHlwZTogJ25lc3RlZC1yZXNpemUtZW5kJyxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgLi4uY3VyU3RhdGUuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAuLi5uZXdTdHlsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemVQYW5lcyA9IChwYW5lcywgd2lkdGhzKSA9PiB7XG4gICAgICBpZiAod2lkdGhzICE9PSBudWxsKSB7XG4gICAgICAgIHBhbmVzLmZvckVhY2gocGFuZSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGVPYmplY3QgPSB7XG4gICAgICAgICAgICBmbGV4OiBgMCAwICR7d2lkdGhzW3BhbmUuaWRdfWBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghcGFuZS50cmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICBzdHlsZU9iamVjdC5sZWZ0ID0gJzBweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhbmUuc2V0U3R5bGUoc3R5bGVPYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlUGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBzaG91bGRSZXNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShvbGRTdGF0ZSA9PiB7XG4gICAgICAgIC8vIGFjY291bnRzIGZvciBvZGQgc2l0dWF0aW9ucyB3aGVyZSBtdWx0aXBsZSBQYW5lcyBhcmUgZGlzbWlzc2VkL2Rpc21vdW50ZWQgYXQgb25jZS4uLlxuICAgICAgICAvLyBzaW1wbHkgZmlsdGVycyBvdXQgYW55IHRoYXQgaGF2ZSBkaXNtb3VudGVkLlxuICAgICAgICBjb25zdCBuZXdQYW5lcyA9IG9sZFN0YXRlLnBhbmVzLmZpbHRlcihwID0+IHAuaXNUaGlzTW91bnRlZCgpKTtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBvbGRTdGF0ZSk7XG4gICAgICAgIG5ld1N0YXRlLnBhbmVzID0gbmV3UGFuZXM7XG4gICAgICAgIG5ld1N0YXRlLmNoYW5nZVR5cGUgPSAncmVtb3ZlZCc7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZFJlc2l6ZSkgX3RoaXMuY2FsY1dpZHRoc0FuZFJlc2l6ZSgncmVtb3ZlZCcpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdGVyUGFuZSA9IHBhbmVPYmplY3QgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZShvbGRTdGF0ZSA9PiB7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIG9sZFN0YXRlKTtcbiAgICAgICAgLy8gaWYgdGhlIG5ldyBwYW5lIGhhcyBhIHRyYW5zaXRpb24ganVzdCBzZXQgaXRzIHN0YXJ0aW5nIGFwcGVhcmFuY2UuLi5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHJlc2l6ZSBhbGwgdGhlIHBhbmVzLi4uXG4gICAgICAgIGlmIChwYW5lT2JqZWN0LnRyYW5zaXRpb24gIT09ICdub25lJykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0KHBhbmVPYmplY3QpO1xuICAgICAgICAgIHRoaXMucmVzaXplUGFuZXMobmV3U3RhdGUucGFuZXMsIHRoaXMud2lkdGhzKTsgLy8gcGFzcyBjYWNoZWQgd2lkdGhzXG4gICAgICAgICAgbmV3U3RhdGUucGFuZXMucHVzaChwYW5lT2JqZWN0KTtcbiAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25FbmQocGFuZU9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjaGVjayBmb3IgZHVwbGljYXRlIGlkJ3MgYmVmb3JlIHJlZ2lzdGVyaW5nLiBSZWdpc3RyYXRpb24gaGFwcGVucyBvbiBtb3VudC5cbiAgICAgICAgICAvLyBUaGlzIHdpbGwgaGVscCB3aXRoIG1vdW50LXR3aWNlIHN0cmljdCBtb2RlIHN0cmFuZ2VuZXNzXG4gICAgICAgICAgY29uc3QgcGFuZUV4aXN0cyA9IG5ld1N0YXRlLnBhbmVzLmZpbmRJbmRleChwID0+IHAuaWQgPT09IHBhbmVPYmplY3QuaWQpO1xuICAgICAgICAgIGlmIChwYW5lRXhpc3RzID09PSAtMSkge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IHNvcnRlZCBieSBsZWZ0IGNvb3JkaW5hdGUgb2YgY2xpZW50cmVjdC4uLlxuICAgICAgICAgICAgY29uc3QgbmV3UGFuZXMgPSBpbnNlcnRCeUNsaWVudFJlY3QobmV3U3RhdGUucGFuZXMsIHBhbmVPYmplY3QpO1xuICAgICAgICAgICAgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKG5ld1N0YXRlLCB7XG4gICAgICAgICAgICAgIHBhbmVzOiBuZXdQYW5lcyxcbiAgICAgICAgICAgICAgY2hhbmdlVHlwZTogJ2FkZGVkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBuZXdTdGF0ZSA9IHRoaXMuaW5zZXJ0UGFuZU9iamVjdChuZXdTdGF0ZSwgcGFuZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWxjV2lkdGhzQW5kUmVzaXplKCdhZGRlZCcpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBzb21ldGltZXMgdGhlIGNhY2hlZCBzaXplcyBtaWdodCBub3QgbWF0Y2ggdXAgdG8gdGhlIGFjdHVhbCBjb250YWluZXJcbiAgICAvLyBkdWUgdGhlIHdpbmRvdyBiZWluZyBhIGRpZmZlcmVudCBzaXplIHdoZW4gdGhlIGNhY2hlIHdhcyBjcmVhdGVkLlxuICAgIC8vIElmIHRoYXQncyB0cnVlLCBzY2FsZSB0aGUgY2FjaGVkIHNpemVzIGFjY29yZGluZ2x5LlxuICAgIHRoaXMucmVzaXplQ2FjaGVkU2l6ZXNUb0ZpdCA9IGxheW91dEluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0Q2FjaGVcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYW5lc2V0XG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGxheW91dE9iamVjdCA9IGxheW91dENhY2hlW2xheW91dEluZGV4XTtcbiAgICAgIGNvbnN0IGxheW91dFVuaXRUeXBlcyA9IHt9O1xuICAgICAgbGV0IG5ld0NhY2hlT2JqZWN0ID0ge307XG4gICAgICBpZiAoIXBhbmVzZXQpIHtcbiAgICAgICAgLy8gc3VtIHRoZSBwaXhlbHMuLi5cbiAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgcCBpbiBsYXlvdXRPYmplY3QpIHtcbiAgICAgICAgICBpZiAobGF5b3V0T2JqZWN0W3BdKSB7XG4gICAgICAgICAgICBjb25zdCB1bml0ID0gcGFyc2VDU1NVbml0KGxheW91dE9iamVjdFtwXSk7XG4gICAgICAgICAgICBsYXlvdXRVbml0VHlwZXNbcF0gPSB1bml0O1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdweCcpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmNlaWwocGFyc2VJbnQobGF5b3V0T2JqZWN0W3BdLCAxMCkpO1xuICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAncGVyY2VudCcpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KGxheW91dE9iamVjdFtwXSwgMTApIC8gMTAwICogKHRoaXMuY29udGFpbmVyV2lkdGggfHwgd2luZG93LmlubmVyV2lkdGgpO1xuICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYWxsIHBhbmVzIGFyZSBub24tcGl4ZWwsIHJlc2l6ZSB0aGUgbGFzdCBwYW5lXG4gICAgICAgIC8vIGlmIHRoZSBwZXJjZW50YWdlcyBkb24ndCBhZGQgdXAgdG8gMTAwJSBmb3IgcGFuZXNldHMgb2YgMyBvciBtb3JlIHBhbmVzXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGxheW91dFVuaXRUeXBlcykuZXZlcnkodiA9PiB2ID09PSAncGVyY2VudCcgfHwgdiA9PT0gJ3Z3JykpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aHMgPSBPYmplY3Qua2V5cyhsYXlvdXRPYmplY3QpO1xuICAgICAgICAgIGlmICh3aWR0aHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbGV0IHRvdGFsUGVyY2VudFdpZHRoID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0ge307XG4gICAgICAgICAgICB3aWR0aHMuZm9yRWFjaCgodywgaSkgPT4ge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KGxheW91dE9iamVjdFt3XSwgMTApO1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gd2lkdGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXdXaWR0aC5pZCA9IHc7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGguZGVmYXVsdFdpZHRoID0gYCR7MTAwIC0gdG90YWxQZXJjZW50V2lkdGh9JWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG90YWxQZXJjZW50V2lkdGggKz0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3Q2FjaGVPYmplY3QgPSB7XG4gICAgICAgICAgICAgIC4uLm5ld0NhY2hlT2JqZWN0LFxuICAgICAgICAgICAgICBbbmV3V2lkdGguaWRdOiBuZXdXaWR0aC5kZWZhdWx0V2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29udGFpbmVyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmxheW91dE9iamVjdCxcbiAgICAgICAgICAgICAgLi4ubmV3Q2FjaGVPYmplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHdpbmRvdyBzaXplIGhhcyBub3QgY2hhbmdlZCwgdGhlIGNhY2hlZCBwYW5lIHdpZHRocyBtYXkgc3RpbGwgbmVlZCB0byBiZSB2YWxpZGF0ZWQuLi5cbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMucHJldmlvdXNDb250YWluZXJXaWR0aCAtIHdpbmRvdy5pbm5lcldpZHRoKSA8IDEpIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5wcmV2aW91c0NvbnRhaW5lcldpZHRoIC0gdG90YWxXaWR0aCkgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wb3J0aW9uID0gdGhpcy5wcmV2aW91c0NvbnRhaW5lcldpZHRoIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBsYXlvdXRPYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKGxheW91dE9iamVjdFtwXSAmJiBpc1VuaXRQaXhlbEJhc2VkKGxheW91dFVuaXRUeXBlc1twXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IGdldE5ld1BhbmV3aWR0aE9iamVjdChwLCBsYXlvdXRPYmplY3RbcF0sIHByb3BvcnRpb24pO1xuICAgICAgICAgICAgICAgIG5ld0NhY2hlT2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgLi4ubmV3Q2FjaGVPYmplY3QsXG4gICAgICAgICAgICAgICAgICBbbmV3V2lkdGguaWRdOiBuZXdXaWR0aC5kZWZhdWx0V2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29udGFpbmVyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmxheW91dE9iamVjdCxcbiAgICAgICAgICAgICAgLi4ubmV3Q2FjaGVPYmplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRDYWNoZVtsYXlvdXRJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzaXplVG9Db250YWluZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmNhbGNXaWR0aHNBbmRSZXNpemUgPSBjaGFuZ2VUeXBlID0+IHtcbiAgICAgIHRoaXMud2lkdGhzUkFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgbGV0IHdpZHRocztcbiAgICAgICAgY29uc3QgbmV4dExheW91dCA9IHt9O1xuICAgICAgICB0aGlzLnN0YXRlLnBhbmVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgbmV4dExheW91dFtwLmlkXSA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaXplc0NhY2hlZCA9IHRoaXMuY2FjaGVkTGF5b3V0SW5kZXgobmV4dExheW91dCk7XG4gICAgICAgIGNvbnN0IHRvQXBwbHkgPSB0aGlzLnByb3BzLm9uTGF5b3V0KHtcbiAgICAgICAgICBjaGFuZ2VUeXBlLFxuICAgICAgICAgIG5leHRMYXlvdXQsXG4gICAgICAgICAgbGF5b3V0Q2FjaGVkOiBzaXplc0NhY2hlZCA9PT0gLTEsXG4gICAgICAgICAgbGF5b3V0Q2FjaGU6IHRoaXMuc3RhdGUubGF5b3V0Q2FjaGUsXG4gICAgICAgICAgd2lkdGhzOiBzaXplc0NhY2hlZCAhPT0gLTEgPyBudWxsIDogdGhpcy5zdGF0ZS5sYXlvdXRDYWNoZVtzaXplc0NhY2hlZF1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0b0FwcGx5ICE9PSBudWxsICYmIHNpemVzQ2FjaGVkID09PSAtMSkge1xuICAgICAgICAgIHdpZHRocyA9IHRvQXBwbHk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZXNDYWNoZWQgIT09IC0xKSB7XG4gICAgICAgICAgd2lkdGhzID0gdGhpcy5yZXNpemVDYWNoZWRTaXplc1RvRml0KHNpemVzQ2FjaGVkKSB8fCB0aGlzLnN0YXRlLmxheW91dENhY2hlW3NpemVzQ2FjaGVkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aHMgPSB0aGlzLmNhbGNXaWR0aHModGhpcy5zdGF0ZS5wYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemVQYW5lcyh0aGlzLnN0YXRlLnBhbmVzLCB3aWR0aHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxheW91dENhY2hlKHdpZHRocywgY2hhbmdlVHlwZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0ID0gcGFuZSA9PiB7XG4gICAgICBpZiAocGFuZS50cmFuc2l0aW9uID09PSAnc2xpZGUnKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlT2JqZWN0ID0ge307XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlSW50KHBhbmUuZGVmYXVsdFdpZHRoLCAxMCkpKSB7XG4gICAgICAgICAgc3R5bGVPYmplY3QuZmxleCA9IGAwIDAgJHtwYW5lLmRlZmF1bHRXaWR0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlT2JqZWN0LmxlZnQgPSAnMTAwdncnO1xuICAgICAgICBzdHlsZU9iamVjdC50cmFuc2l0aW9uID0gJ2xlZnQgLjI1cyBlYXNlJztcbiAgICAgICAgcGFuZS50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgICAgcGFuZS5zZXRTdHlsZShzdHlsZU9iamVjdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnRyYW5zaXRpb25FbmQgPSBwYW5lID0+IHtcbiAgICAgIHBhbmUudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jYWxjV2lkdGhzQW5kUmVzaXplKCdlbmRlZFRyYW5zaXRpb24nKTtcbiAgICB9O1xuICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gaWQgPT4ge1xuICAgICAgY29uc3QgcGFuZSA9IHRoaXMuc3RhdGUucGFuZXMuZmlsdGVyKHAgPT4gcC5pZCA9PT0gaWQpWzBdO1xuICAgICAgcmV0dXJuICEhcGFuZTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ2xvc2UgPSAoaWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBwYW5lID0gdGhpcy5zdGF0ZS5wYW5lcy5maWx0ZXIocCA9PiBwLmlkID09PSBpZClbMF07XG4gICAgICBpZiAocGFuZS50cmFuc2l0aW9uICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhcnQocGFuZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlUGFuZSgpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25FbmQocGFuZSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvbkNhbGxiYWNrVE8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQYW5lKCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2FsY1dpZHRocyA9IHBhbmVzID0+IHtcbiAgICAgIC8vIGZpbmQgYWxsIHN0YXRpYyB3aWR0aHMuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhbmVzZXRcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgbGV0IHN0YXRpY1NwYWNlID0gMDtcbiAgICAgIGNvbnN0IGR5bmFtaWNzID0gW107XG4gICAgICBjb25zdCByZXNXaWR0aHMgPSB7fTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLndpZHRocyA9IHJlc1dpZHRocztcbiAgICAgICAgcmV0dXJuIHJlc1dpZHRocztcbiAgICAgIH1cbiAgICAgIGxldCBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcblxuICAgICAgLy8gaWYgY29udGFpbmVyV2lkdGggaXMgMCwgdXNlIHRoZSB3aW5kb3dXaWR0aCB0byBhdm9pZCBkaXZpZGluZyBieSAwLi4uXG4gICAgICBpZiAoY29udGFpbmVyV2lkdGggPT09IDAgJiYgIXBhbmVzZXQpIHtcbiAgICAgICAgY29udGFpbmVyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIH1cbiAgICAgIHBhbmVzLmZvckVhY2gocGFuZSA9PiB7XG4gICAgICAgIGlmIChwYW5lLnN0YXRpY1dpZHRoICYmIHRoaXMucHJldmlvdXNDb250YWluZXJXaWR0aCA9PT0gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICBzdGF0aWNTcGFjZSArPSBwYW5lLnN0YXRpY1dpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYW5lV2lkdGggPSBwYXJzZUludChwYW5lLmRlZmF1bHRXaWR0aCwgMTApO1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGdldCBhbiBpbnQgZnJvbSBkZWZhdWx0IHdpZHRoLCBpdCdzIHNvbWV0aGluZyBkeW5hbWljIGxpa2UgJ2ZpbGwnXG4gICAgICAgICAgaWYgKE51bWJlci5pc05hTihjdXJyZW50UGFuZVdpZHRoKSkge1xuICAgICAgICAgICAgZHluYW1pY3MucHVzaChwYW5lLmlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyc2UgdW5pdFxuICAgICAgICAgICAgY29uc3QgdW5pdCA9IHBhcnNlQ1NTVW5pdChwYW5lLmRlZmF1bHRXaWR0aCk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIHBpeGVsc1xuICAgICAgICAgICAgbGV0IHBhcnNlZFdpZHRoO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3BlcmNlbnQnOlxuICAgICAgICAgICAgICBjYXNlICd2dyc6XG4gICAgICAgICAgICAgICAgcGFyc2VkV2lkdGggPSBjdXJyZW50UGFuZVdpZHRoICogMC4wMSAqIGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdweCc6XG4gICAgICAgICAgICAgICAgcGFyc2VkV2lkdGggPSBjdXJyZW50UGFuZVdpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlbSc6XG4gICAgICAgICAgICAgICAgLy8gc3lzdGVtIHJlbSBvZiAxNFxuICAgICAgICAgICAgICAgIHBhcnNlZFdpZHRoID0gY3VycmVudFBhbmVXaWR0aCAqIDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHBhcnNlZFdpZHRoID0gY3VycmVudFBhbmVXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpY1NwYWNlICs9IHBhcnNlZFdpZHRoO1xuICAgICAgICAgICAgcGFuZS5zdGF0aWNXaWR0aCA9IHBhcnNlZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzdGF0aWNQZXJjZW50ID0gKGNvbnRhaW5lcldpZHRoIC0gc3RhdGljU3BhY2UpIC8gY29udGFpbmVyV2lkdGggKiAxMDA7XG4gICAgICBjb25zdCBiYXNlUGVyY2VudGFnZSA9IHN0YXRpY1BlcmNlbnQgLyBNYXRoLm1heChPYmplY3Qua2V5cyhkeW5hbWljcykubGVuZ3RoLCAxKTtcbiAgICAgIHBhbmVzLmZvckVhY2goKHBhbmUsIGkpID0+IHtcbiAgICAgICAgaWYgKGR5bmFtaWNzLmluZGV4T2YocGFuZS5pZCkgIT09IC0xKSB7XG4gICAgICAgICAgcmVzV2lkdGhzW3BhbmUuaWRdID0gYCR7YmFzZVBlcmNlbnRhZ2V9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzV2lkdGhzW3BhbmUuaWRdID0gcGFuZXNbaV0uZGVmYXVsdFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMud2lkdGhzID0gcmVzV2lkdGhzO1xuICAgICAgcmV0dXJuIHJlc1dpZHRocztcbiAgICB9O1xuICAgIHRoaXMuZ2V0UmVmID0gKCkgPT4gdGhpcy5jb250YWluZXI7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSA9ICgpID0+IHRoaXM7XG4gICAgLyoqXG4gICAgICogY2FjaGVkTGF5b3V0SW5kZXhcbiAgICAgKiBTZWFyY2ggc3RhdGUubGF5b3V0Q2FjaGUgZm9yIGFuIG9iamVjdCB3aG9zZSBrZXlzIGV4YWN0bHkgbWF0Y2ggdGhvc2VcbiAgICAgKiBpbiB0aGUgY2FuZGlkYXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYW5kaWRhdGVcbiAgICAgKiBAcmV0dXJucyBpbnQgaW5kZXggaW4gc3RhdGUubGF5b3V0Q2FjaGUgb2YgdGhlIG1hdGNoaW5nIGNhY2hlLCBvciAtMVxuICAgICAqL1xuICAgIHRoaXMuY2FjaGVkTGF5b3V0SW5kZXggPSBjYW5kaWRhdGUgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubGF5b3V0Q2FjaGU/LmZpbmRJbmRleChjYWNoZSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlS2V5cyA9IE9iamVjdC5rZXlzKGNhbmRpZGF0ZSk7XG4gICAgICAgIGlmIChjYWNoZUtleXMubGVuZ3RoID09PSBjYW5kaWRhdGVLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYWNoZUtleXMuZXZlcnkoY2sgPT4gY2FuZGlkYXRlS2V5cy5pbmRleE9mKGNrKSAhPT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pID8/IC0xO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVMYXlvdXRDYWNoZSA9IGxheW91dE1hcCA9PiB7XG4gICAgICBpZiAodGhpcy5pc1RoaXNNb3VudGVkKCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShfcmVmID0+IHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgbGF5b3V0Q2FjaGVcbiAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAvLyBmaW5kIGR1cGxpY2F0ZXMgd2l0aCBsaWtlIGxlbmd0aHMsIGlkJ3MuLi5cbiAgICAgICAgICBjb25zdCBsYXlvdXRJbmRleCA9IHRoaXMuY2FjaGVkTGF5b3V0SW5kZXgobGF5b3V0TWFwKTtcbiAgICAgICAgICBpZiAobGF5b3V0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQ2FjaGUgPSBjbG9uZURlZXAobGF5b3V0Q2FjaGUpO1xuICAgICAgICAgICAgdGVtcENhY2hlW2xheW91dEluZGV4XSA9IGxheW91dE1hcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxheW91dENhY2hlOiB0ZW1wQ2FjaGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRDYWNoZTogWy4uLmxheW91dENhY2hlLCBsYXlvdXRNYXBdLFxuICAgICAgICAgICAgY2hhbmdlVHlwZTogJ3Jlc2l6ZSdcbiAgICAgICAgICB9O1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgLy8gb25seSBjYWxsIHRoZSBvdXRzaWRlIGNhY2hlIHVwZGF0ZSBJRiBhbGwgcGFuZXMgaGF2ZSBub24tZ2VuZXJhdGVkIGlkcy5cbiAgICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBjYWNoZSBpcyBhcHBlbmRlZCBkaWZmZXJlbnQgZXZlcnkgdGltZSBhIHBhbmUgd2l0aCBhIGRpZmZlcmVudCBnZW5lcmF0ZWQgaWQgbW91bnRzLlxuICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uUmVzaXplICYmIHRoaXMuc3RhdGUucGFuZXMuZXZlcnkocCA9PiBwLmhhc0dlbmVyYXRlZElkID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemUoe1xuICAgICAgICAgICAgICBjdXJyZW50TGF5b3V0OiBsYXlvdXRNYXAsXG4gICAgICAgICAgICAgIGxheW91dENhY2hlOiB0aGlzLnN0YXRlLmxheW91dENhY2hlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gQWNjZXB0cyB0aGUgcG9zaXRpb25zIG9mIGhhbmRsZXMsIHRoZSBjbGllbnQgcmVjdCBvZiB0aGUgY29udGFpbmVyLlxuICAgIHRoaXMuaGFuZGxlUGFuZVJlc2l6ZSA9IF9yZWYyID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgY29udGFpbmVyUmVjdCxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IF9yZWYyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYW5lc1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBuZXdXaWR0aHMgPSB7fTtcbiAgICAgIGNvbnN0IG90aGVyV2lkdGhzID0gW107XG4gICAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICBjb25zdCBwb3NpdGlvbkJvdW5kcyA9IG5leHRQb3MgPyBuZXh0UG9zLnggOiBjb250YWluZXJSZWN0LndpZHRoO1xuICAgICAgICBpZiAocGFuZXMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gcG9zLmVsZW1lbnRJZCkgIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBgJHtwb3NpdGlvbkJvdW5kcyAtIHBvcy54fXB4YDtcbiAgICAgICAgICBuZXdXaWR0aHNbcG9zLmVsZW1lbnRJZF0gPSBuZXdXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlciB3aWR0aHMgcmVtYWluIGFzIG51bWJlcnMgZm9yIGZ1dHVyZSBtYXRoIChubyBjc3MgdW5pdCB5ZXQpXG4gICAgICAgICAgb3RoZXJXaWR0aHMucHVzaChwb3NpdGlvbkJvdW5kcyAtIHBvcy54KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYW5lc2V0SW5kZXggPSBwYW5lcy5maW5kSW5kZXgocCA9PiBwLmlzUGFuZXNldCk7XG4gICAgICBpZiAocGFuZXNldEluZGV4ICE9PSAtMSkge1xuICAgICAgICAvLyBzdW0gdGhlIG90aGVyIHdpZHRocyBhcyBhIHBhbmVzZXQgd2lkdGguLi5cbiAgICAgICAgY29uc3QgcGFuZVNldFdpZHRoID0gb3RoZXJXaWR0aHMucmVkdWNlKChzdW0sIHcpID0+IHN1bSArIHcsIDApO1xuICAgICAgICBjb25zdCBwYW5lc2V0SWQgPSBwYW5lc1twYW5lc2V0SW5kZXhdLmlkO1xuICAgICAgICBuZXdXaWR0aHNbcGFuZXNldElkXSA9IHBhbmVTZXRXaWR0aDtcbiAgICAgICAgcGFuZXNbcGFuZXNldEluZGV4XS5oYW5kbGVQYW5lUmVzaXplKHtcbiAgICAgICAgICBwb3NpdGlvbnMsXG4gICAgICAgICAgY29udGFpbmVyUmVjdCxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNpemVQYW5lcyhwYW5lcywgbmV3V2lkdGhzKTtcbiAgICAgIHRoaXMudXBkYXRlTGF5b3V0Q2FjaGUobmV3V2lkdGhzLCAncmVzaXplJyk7XG4gICAgfTtcbiAgICBsZXQgaW5pdFN0eWxlID0ge307XG4gICAgLy8gU2V0IGZpeGVkIHdpZHRoIG9ubHkgZm9yIHBhbmVzIHdpdGggdGhlIGNvdW50ZWQgdmFsdWVcbiAgICBpZiAodGhpcy5wcm9wcy5kZWZhdWx0V2lkdGggIT09ICdmaWxsJykge1xuICAgICAgaW5pdFN0eWxlID0ge1xuICAgICAgICBmbGV4OiBgMCAwICR7dGhpcy5wcm9wcy5kZWZhdWx0V2lkdGh9YFxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHBhbmVNYW5hZ2VyOiB7XG4gICAgICAgIGhhbmRsZUNsb3NlOiB0aGlzLmhhbmRsZUNsb3NlLFxuICAgICAgICByZWdpc3RlclBhbmU6IHRoaXMucmVnaXN0ZXJQYW5lLFxuICAgICAgICByZW1vdmVQYW5lOiB0aGlzLnJlbW92ZVBhbmUsXG4gICAgICAgIGdldENvbnRhaW5lcjogdGhpcy5nZXRDb250YWluZXIsXG4gICAgICAgIGdldFRvcG1vc3RDb250YWluZXI6IHRoaXMuZ2V0VG9wbW9zdENvbnRhaW5lclxuICAgICAgfSxcbiAgICAgIHBhbmVzOiBbXSxcbiAgICAgIC8vIGxheW91dENhY2hlIG11c3Qgbm90IGJlIG51bGwsIGJ1dCBpbml0aWFsTGF5b3V0cyBtYXkgY29tZSBpbiB0aGF0IHdheSxcbiAgICAgIC8vIGUuZy4gaWYgdGhlIGNhbGxpbmcgY29tcG9uZW50IGxvb2tzIGZvciBhIGNhY2hlZCB2YWx1ZSBidXQgZG9lc24ndFxuICAgICAgLy8gZmluZCBvbmUgdGhlbiBpbml0aWFsTGF5b3V0cyB3aWxsIGJlIHByZXNlbnQgYnV0IG51bGwuXG4gICAgICBsYXlvdXRDYWNoZTogcHJvcHMuaW5pdGlhbExheW91dHMgPz8gW10sXG4gICAgICBzdHlsZTogaW5pdFN0eWxlLFxuICAgICAgY2hhbmdlVHlwZTogJ2luaXQnIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tdW51c2VkLXN0YXRlXG4gICAgfTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKTtcbiAgICB0aGlzLnJlc2l6ZUNvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKTtcbiAgICB0aGlzLmlkID0gcHJvcHMuaWQgfHwgdW5pcXVlSWQoJ3BhbmVzZXQtJyk7XG4gICAgdGhpcy53aWR0aHMgPSBbXTtcbiAgICB0aGlzLmludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMuaXNSb290KSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wYW5lc2V0KSB7XG4gICAgICAgIC8vIHJlZ2lzdGVyIHdpdGggcGFyZW50IHBhbmVzZXQgaWYgaXQgZXhpc3RzXG4gICAgICAgIHRoaXMucHJvcHMucGFuZXNldC5yZWdpc3RlclBhbmUoe1xuICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgIHNldFN0eWxlOiB0aGlzLnNldFN0eWxlLFxuICAgICAgICAgIGdldENoaWxkSW5mbzogdGhpcy5nZXRDaGlsZEluZm8sXG4gICAgICAgICAgaXNUaGlzTW91bnRlZDogdGhpcy5pc1RoaXNNb3VudGVkLFxuICAgICAgICAgIGlzUGFuZXNldDogdHJ1ZSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZScsXG4gICAgICAgICAgZG9UcmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgICBnZXRSZWY6IHRoaXMuZ2V0UmVmLFxuICAgICAgICAgIGdldEluc3RhbmNlOiB0aGlzLmdldEluc3RhbmNlLFxuICAgICAgICAgIGhhbmRsZVBhbmVSZXNpemU6IHRoaXMuaGFuZGxlUGFuZVJlc2l6ZSxcbiAgICAgICAgICBnZXRDaGlsZFBhbmVzVG90YWxXaWR0aDogdGhpcy5nZXRDaGlsZFBhbmVzVG90YWxXaWR0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2UodGhpcy5oYW5kbGVXaW5kb3dSZXNpemUsIDUwKSk7XG4gICAgdGhpcy5wcmV2aW91c0NvbnRhaW5lcldpZHRoID0gdGhpcy5jb250YWluZXIuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcik7XG4gICAgaWYgKHRoaXMud2lkdGhzUkFGKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLndpZHRoc1JBRik7XG4gICAgICB0aGlzLndpZHRoc1JBRiA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc2l6ZU5lc3RlZFRPKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVOZXN0ZWRUTyk7XG4gICAgICB0aGlzLnJlc2l6ZU5lc3RlZFRPID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbkNhbGxiYWNrVE8pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25DYWxsYmFja1RPKTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNhbGxiYWNrVE8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgdGhpcy5pbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcm9wcy5pc1Jvb3QgJiYgdGhpcy5wcm9wcy5wYW5lc2V0KSB7XG4gICAgICB0aGlzLnByb3BzLnBhbmVzZXQucmVtb3ZlUGFuZShmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGFuZXNldCxcbiAgICAgIGlzUm9vdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gcHVsbCBhbnkgZGF0YS10ZXN0LSogcHJvcHMgaW50byBhIHNwcmVhZGFibGUgb2JqZWN0XG4gICAgY29uc3QgZGF0YVByb3BzID0gcGlja0J5KHRoaXMucHJvcHMsICh2YWwsIGtleSkgPT4gL15kYXRhLXRlc3QvLnRlc3Qoa2V5KSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KFBhbmVzZXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5wYW5lTWFuYWdlcixcbiAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChQYW5lUmVzaXplQ29udGFpbmVyLCB7XG4gICAgICAgIGlzUm9vdDogaXNSb290IHx8ICFwYW5lc2V0LFxuICAgICAgICBwYXJlbnRFbGVtZW50OiB0aGlzLmNvbnRhaW5lcj8uY3VycmVudCxcbiAgICAgICAgb25FbGVtZW50UmVzaXplOiB0aGlzLmhhbmRsZVBhbmVSZXNpemUsXG4gICAgICAgIHJlc2l6ZUNvbnRhaW5lclJlZjogdGhpcy5yZXNpemVDb250YWluZXIsXG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmdldENsYXNzTmFtZSgpLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBzdHlsZTogdGhpcy5zdGF0ZS5zdHlsZSxcbiAgICAgICAgICByZWY6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgIC4uLmRhdGFQcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn1cblBhbmVzZXQucHJvcFR5cGVzID0ge1xuICAvLyBwYW5lcyBhbmQgb3RoZXIgdGhpbmdzIHRoYXQgcmVuZGVyIHBhbmVzLi5cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAvLyBpZiBuZWNlc3NhcnksIFBhbmVzZXQgY2FuIGJlIGFzc2lnbmVkIGEgcGVyY2VudGFnZSB3aWR0aC5cbiAgZGVmYXVsdFdpZHRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvLyBpZCBhdHRyaWJ1dGUgYXBwbGllZCB0byBvdXRlciA8ZGl2Pi5cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8vIHVzZWQgdG8gaW5pdGlhbGl6ZSBMYXlvdXQgQ2FjaGUgb2YgcGFuZXNldCB3aWR0aHNcbiAgaW5pdGlhbExheW91dHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuICAvLyB0aGlzIHBhbmVzZXQgd2lsbCBub3QgcmVwb3J0IGl0c2VsZiB0byBhbiBhc2NlbmRlbnQgcGFuZXNldFxuICBpc1Jvb3Q6IFByb3BUeXBlcy5ib29sLFxuICAvLyBhcHBsaWVzIHN0eWxpbmcgdG8gcHJvcGVybHkgbmVzdCB0aGUgcGFuZXNldFxuICBuZXN0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvLyBjYWxsYmFjayBmb3Igb3ZlcnJpZGluZyBsYXlvdXQgZnJvbSB0aGUgYXBwbGljYXRpb24gbGV2ZWxcbiAgb25MYXlvdXQ6IFByb3BUeXBlcy5mdW5jLFxuICAvLyBjYWxsYmFjayB3aGVuIHBhbmVzIGFyZSByZXNpemVkIGJ5IHRoZSB1c2VyLlxuICBvblJlc2l6ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIHRoZSBwYXJlbnQgcGFuZXNldCBvZiB0aGUgY3VycmVudCBwYW5lc2V0XG4gIHBhbmVzZXQ6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZ2V0VG9wbW9zdENvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaGFuZGxlQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJlZ2lzdGVyUGFuZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmVtb3ZlUGFuZTogUHJvcFR5cGVzLmZ1bmNcbiAgfSksXG4gIC8vIHNldCBpZiB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lc2V0IG5lZWRzIHRvIGJlIGNvbnRyb2xsZWQuXG4gIHN0YXRpYzogUHJvcFR5cGVzLmJvb2xcbn07XG5QYW5lc2V0LmRpc3BsYXlOYW1lID0gXCJQYW5lc2V0XCI7XG5QYW5lc2V0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IHdpdGhQYW5lc2V0KFBhbmVzZXQpO1xuO1xuUGFuZXNldC5fX2RvY2dlbkluZm8gPSB7XG4gIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgXCJtZXRob2RzXCI6IFt7XG4gICAgXCJuYW1lXCI6IFwicmVzaXplVG9Db250YWluZXJcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW10sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcInJlc2l6ZU5lc3RlZFBhbmVzZXRzXCIsXG4gICAgXCJkb2NibG9ja1wiOiBudWxsLFxuICAgIFwibW9kaWZpZXJzXCI6IFtdLFxuICAgIFwicGFyYW1zXCI6IFtdLFxuICAgIFwicmV0dXJuc1wiOiBudWxsXG4gIH0sIHtcbiAgICBcIm5hbWVcIjogXCJnZXRDaGlsZFBhbmVzVG90YWxXaWR0aFwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgXCJuYW1lXCI6IFwicGFuZXNMaXN0XCIsXG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogbnVsbFxuICAgIH1dLFxuICAgIFwicmV0dXJuc1wiOiBudWxsXG4gIH0sIHtcbiAgICBcIm5hbWVcIjogXCJoYW5kbGVXaW5kb3dSZXNpemVcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW10sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcImlzVGhpc01vdW50ZWRcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW10sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcImdldENvbnRhaW5lclwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbXSxcbiAgICBcInJldHVybnNcIjogbnVsbFxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwiZ2V0VG9wbW9zdENvbnRhaW5lclwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbXSxcbiAgICBcInJldHVybnNcIjogbnVsbFxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwiZ2V0Q2xhc3NOYW1lXCIsXG4gICAgXCJkb2NibG9ja1wiOiBudWxsLFxuICAgIFwibW9kaWZpZXJzXCI6IFtdLFxuICAgIFwicGFyYW1zXCI6IFtdLFxuICAgIFwicmV0dXJuc1wiOiBudWxsXG4gIH0sIHtcbiAgICBcIm5hbWVcIjogXCJzZXRTdHlsZVwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbXSxcbiAgICBcInJldHVybnNcIjogbnVsbFxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwicmVzaXplUGFuZXNcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcInBhbmVzXCIsXG4gICAgICBcIm9wdGlvbmFsXCI6IGZhbHNlLFxuICAgICAgXCJ0eXBlXCI6IG51bGxcbiAgICB9LCB7XG4gICAgICBcIm5hbWVcIjogXCJ3aWR0aHNcIixcbiAgICAgIFwib3B0aW9uYWxcIjogZmFsc2UsXG4gICAgICBcInR5cGVcIjogbnVsbFxuICAgIH1dLFxuICAgIFwicmV0dXJuc1wiOiBudWxsXG4gIH0sIHtcbiAgICBcIm5hbWVcIjogXCJyZW1vdmVQYW5lXCIsXG4gICAgXCJkb2NibG9ja1wiOiBudWxsLFxuICAgIFwibW9kaWZpZXJzXCI6IFtdLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICBcIm5hbWVcIjogXCJzaG91bGRSZXNpemVcIixcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBudWxsXG4gICAgfV0sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcInJlZ2lzdGVyUGFuZVwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgXCJuYW1lXCI6IFwicGFuZU9iamVjdFwiLFxuICAgICAgXCJvcHRpb25hbFwiOiBmYWxzZSxcbiAgICAgIFwidHlwZVwiOiBudWxsXG4gICAgfV0sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcInJlc2l6ZUNhY2hlZFNpemVzVG9GaXRcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcImxheW91dEluZGV4XCIsXG4gICAgICBcIm9wdGlvbmFsXCI6IGZhbHNlLFxuICAgICAgXCJ0eXBlXCI6IG51bGxcbiAgICB9XSxcbiAgICBcInJldHVybnNcIjogbnVsbFxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwiY2FsY1dpZHRoc0FuZFJlc2l6ZVwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgXCJuYW1lXCI6IFwiY2hhbmdlVHlwZVwiLFxuICAgICAgXCJvcHRpb25hbFwiOiBmYWxzZSxcbiAgICAgIFwidHlwZVwiOiBudWxsXG4gICAgfV0sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcInRyYW5zaXRpb25TdGFydFwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgXCJuYW1lXCI6IFwicGFuZVwiLFxuICAgICAgXCJvcHRpb25hbFwiOiBmYWxzZSxcbiAgICAgIFwidHlwZVwiOiBudWxsXG4gICAgfV0sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcInRyYW5zaXRpb25FbmRcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcInBhbmVcIixcbiAgICAgIFwib3B0aW9uYWxcIjogZmFsc2UsXG4gICAgICBcInR5cGVcIjogbnVsbFxuICAgIH1dLFxuICAgIFwicmV0dXJuc1wiOiBudWxsXG4gIH0sIHtcbiAgICBcIm5hbWVcIjogXCJpc1JlZ2lzdGVyZWRcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcImlkXCIsXG4gICAgICBcIm9wdGlvbmFsXCI6IGZhbHNlLFxuICAgICAgXCJ0eXBlXCI6IG51bGxcbiAgICB9XSxcbiAgICBcInJldHVybnNcIjogbnVsbFxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwiaGFuZGxlQ2xvc2VcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcImlkXCIsXG4gICAgICBcIm9wdGlvbmFsXCI6IGZhbHNlLFxuICAgICAgXCJ0eXBlXCI6IG51bGxcbiAgICB9LCB7XG4gICAgICBcIm5hbWVcIjogXCJjYWxsYmFja1wiLFxuICAgICAgXCJvcHRpb25hbFwiOiBmYWxzZSxcbiAgICAgIFwidHlwZVwiOiBudWxsXG4gICAgfV0sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcImNhbGNXaWR0aHNcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcInBhbmVzXCIsXG4gICAgICBcIm9wdGlvbmFsXCI6IGZhbHNlLFxuICAgICAgXCJ0eXBlXCI6IG51bGxcbiAgICB9XSxcbiAgICBcInJldHVybnNcIjogbnVsbFxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwiZ2V0UmVmXCIsXG4gICAgXCJkb2NibG9ja1wiOiBudWxsLFxuICAgIFwibW9kaWZpZXJzXCI6IFtdLFxuICAgIFwicGFyYW1zXCI6IFtdLFxuICAgIFwicmV0dXJuc1wiOiBudWxsXG4gIH0sIHtcbiAgICBcIm5hbWVcIjogXCJnZXRJbnN0YW5jZVwiLFxuICAgIFwiZG9jYmxvY2tcIjogbnVsbCxcbiAgICBcIm1vZGlmaWVyc1wiOiBbXSxcbiAgICBcInBhcmFtc1wiOiBbXSxcbiAgICBcInJldHVybnNcIjogbnVsbFxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwiY2FjaGVkTGF5b3V0SW5kZXhcIixcbiAgICBcImRvY2Jsb2NrXCI6IFwiY2FjaGVkTGF5b3V0SW5kZXhcXG5TZWFyY2ggc3RhdGUubGF5b3V0Q2FjaGUgZm9yIGFuIG9iamVjdCB3aG9zZSBrZXlzIGV4YWN0bHkgbWF0Y2ggdGhvc2VcXG5pbiB0aGUgY2FuZGlkYXRlLlxcbkBwYXJhbSB7b2JqZWN0fSBjYW5kaWRhdGVcXG5AcmV0dXJucyBpbnQgaW5kZXggaW4gc3RhdGUubGF5b3V0Q2FjaGUgb2YgdGhlIG1hdGNoaW5nIGNhY2hlLCBvciAtMVwiLFxuICAgIFwibW9kaWZpZXJzXCI6IFtdLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICBcIm5hbWVcIjogXCJjYW5kaWRhdGVcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcIm9iamVjdFwiXG4gICAgICB9LFxuICAgICAgXCJvcHRpb25hbFwiOiBmYWxzZVxuICAgIH1dLFxuICAgIFwicmV0dXJuc1wiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiaW50IGluZGV4IGluIHN0YXRlLmxheW91dENhY2hlIG9mIHRoZSBtYXRjaGluZyBjYWNoZSwgb3IgLTFcIlxuICAgIH0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcImNhY2hlZExheW91dEluZGV4XFxuU2VhcmNoIHN0YXRlLmxheW91dENhY2hlIGZvciBhbiBvYmplY3Qgd2hvc2Uga2V5cyBleGFjdGx5IG1hdGNoIHRob3NlXFxuaW4gdGhlIGNhbmRpZGF0ZS5cIlxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwidXBkYXRlTGF5b3V0Q2FjaGVcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcImxheW91dE1hcFwiLFxuICAgICAgXCJvcHRpb25hbFwiOiBmYWxzZSxcbiAgICAgIFwidHlwZVwiOiBudWxsXG4gICAgfV0sXG4gICAgXCJyZXR1cm5zXCI6IG51bGxcbiAgfSwge1xuICAgIFwibmFtZVwiOiBcImhhbmRsZVBhbmVSZXNpemVcIixcbiAgICBcImRvY2Jsb2NrXCI6IG51bGwsXG4gICAgXCJtb2RpZmllcnNcIjogW10sXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcInsgcG9zaXRpb25zLCBjb250YWluZXJSZWN0LCAuLi5yZXN0IH1cIixcbiAgICAgIFwib3B0aW9uYWxcIjogZmFsc2UsXG4gICAgICBcInR5cGVcIjogbnVsbFxuICAgIH1dLFxuICAgIFwicmV0dXJuc1wiOiBudWxsXG4gIH1dLFxuICBcImRpc3BsYXlOYW1lXCI6IFwiUGFuZXNldFwiLFxuICBcInByb3BzXCI6IHtcbiAgICBcImRlZmF1bHRXaWR0aFwiOiB7XG4gICAgICBcImRlZmF1bHRWYWx1ZVwiOiB7XG4gICAgICAgIFwidmFsdWVcIjogXCInZmlsbCdcIixcbiAgICAgICAgXCJjb21wdXRlZFwiOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJvbkxheW91dFwiOiB7XG4gICAgICBcImRlZmF1bHRWYWx1ZVwiOiB7XG4gICAgICAgIFwidmFsdWVcIjogXCIoKSA9PiBudWxsXCIsXG4gICAgICAgIFwiY29tcHV0ZWRcIjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImluaXRpYWxMYXlvdXRzXCI6IHtcbiAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IHtcbiAgICAgICAgXCJ2YWx1ZVwiOiBcIltdXCIsXG4gICAgICAgIFwiY29tcHV0ZWRcIjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJhcnJheU9mXCIsXG4gICAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICAgIFwibmFtZVwiOiBcIm9iamVjdFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImNoaWxkcmVuXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiaWRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImlzUm9vdFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcIm5lc3RlZFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcIm9uUmVzaXplXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImZ1bmNcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwicGFuZXNldFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgICBcInR5cGVcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJzaGFwZVwiLFxuICAgICAgICBcInZhbHVlXCI6IHtcbiAgICAgICAgICBcImdldFRvcG1vc3RDb250YWluZXJcIjoge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZnVuY1wiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoYW5kbGVDbG9zZVwiOiB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlZ2lzdGVyUGFuZVwiOiB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmdW5jXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBhbmVcIjoge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZnVuY1wiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwic3RhdGljXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/Paneset/Paneset.js\n\n}')},"./util/parseCSSUnit.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ parseCSSUnit)\n/* harmony export */ });\nfunction parseCSSUnit(str) {\n  if (typeof str === 'number') {\n    return 'px';\n  }\n  const testString = str.toLowerCase();\n  if (/%$/.test(testString)) return 'percent';\n  if (/px$/.test(testString)) return 'px';\n  if (/rem$/.test(testString)) return 'rem';\n  if (/em$/.test(testString)) return 'em';\n  if (/vw$/.test(testString)) return 'vw';\n  // if nothing else, return percent..\n  return 'percent';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlsL3BhcnNlQ1NTVW5pdC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi91dGlsL3BhcnNlQ1NTVW5pdC5qcz80NmE2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlQ1NTVW5pdChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICdweCc7XG4gIH1cbiAgY29uc3QgdGVzdFN0cmluZyA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICBpZiAoLyUkLy50ZXN0KHRlc3RTdHJpbmcpKSByZXR1cm4gJ3BlcmNlbnQnO1xuICBpZiAoL3B4JC8udGVzdCh0ZXN0U3RyaW5nKSkgcmV0dXJuICdweCc7XG4gIGlmICgvcmVtJC8udGVzdCh0ZXN0U3RyaW5nKSkgcmV0dXJuICdyZW0nO1xuICBpZiAoL2VtJC8udGVzdCh0ZXN0U3RyaW5nKSkgcmV0dXJuICdlbSc7XG4gIGlmICgvdnckLy50ZXN0KHRlc3RTdHJpbmcpKSByZXR1cm4gJ3Z3JztcbiAgLy8gaWYgbm90aGluZyBlbHNlLCByZXR1cm4gcGVyY2VudC4uXG4gIHJldHVybiAncGVyY2VudCc7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./util/parseCSSUnit.js\n\n}")},"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/PaneResize.css"(module,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/css-loader/dist/runtime/sourceMaps.js");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/css-loader/dist/runtime/api.js");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* widened hover area to keep mouse cursor from flickering */\n.cursorHover---ADCn0 {\n  position: absolute;\n  height: 100%;\n  width: 20px;\n  pointer-events: all;\n  cursor: col-resize;\n}\n.cursorActive---uWX7w {\n  display: flex;\n  justify-content: center;\n}\n.cursor---OR3F6 {\n  height: 100%;\n  width: 1px;\n  border-right: 2px dashed rgba(0 0 0 / 20%);\n  align-self: stretch;\n}\n.handle---zOCzn {\n  position: absolute;\n  height: 100%;\n  width: 6px;\n  cursor: col-resize;\n  pointer-events: all;\n  background-color: transparent;\n  transition: background-color 0.2s;\n\n  &:hover,\n  &.active---WV7ki {\n    background-color: rgba(0 0 0 / 10%);\n  }\n}\n.container---opN93 {\n  pointer-events: none;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n`, "",{"version":3,"sources":["webpack://./lib/Paneset/PaneResize.css"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D;EACE,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,mBAAmB;EACnB,kBAAkB;AACpB;AAEA;EACE,aAAa;EACb,uBAAuB;AACzB;AAEA;EACE,YAAY;EACZ,UAAU;EACV,0CAA0C;EAC1C,mBAAmB;AACrB;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,UAAU;EACV,kBAAkB;EAClB,mBAAmB;EACnB,6BAA6B;EAC7B,iCAAiC;;EAEjC;;IAEE,mCAAmC;EACrC;AACF;AAEA;EACE,oBAAoB;EACpB,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,MAAM;EACN,OAAO;AACT","sourcesContent":["/* widened hover area to keep mouse cursor from flickering */\\n.cursorHover {\\n  position: absolute;\\n  height: 100%;\\n  width: 20px;\\n  pointer-events: all;\\n  cursor: col-resize;\\n}\\n\\n.cursorActive {\\n  display: flex;\\n  justify-content: center;\\n}\\n\\n.cursor {\\n  height: 100%;\\n  width: 1px;\\n  border-right: 2px dashed rgba(0 0 0 / 20%);\\n  align-self: stretch;\\n}\\n\\n.handle {\\n  position: absolute;\\n  height: 100%;\\n  width: 6px;\\n  cursor: col-resize;\\n  pointer-events: all;\\n  background-color: transparent;\\n  transition: background-color 0.2s;\\n\\n  &:hover,\\n  &.active {\\n    background-color: rgba(0 0 0 / 10%);\\n  }\\n}\\n\\n.container {\\n  pointer-events: none;\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n}\\n"],"sourceRoot":""}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t"cursorHover": `cursorHover---ADCn0`,\n\t"cursorActive": `cursorActive---uWX7w`,\n\t"cursor": `cursor---OR3F6`,\n\t"handle": `handle---zOCzn`,\n\t"active": `active---WV7ki`,\n\t"container": `container---opN93`\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0udXNlWzJdIS4vbGliL1BhbmVzZXQvUGFuZVJlc2l6ZS5jc3MiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZm9saW8vc3RyaXBlcy1jb21wb25lbnRzLy4vbGliL1BhbmVzZXQvUGFuZVJlc2l6ZS5jc3M/MDlkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLyogd2lkZW5lZCBob3ZlciBhcmVhIHRvIGtlZXAgbW91c2UgY3Vyc29yIGZyb20gZmxpY2tlcmluZyAqL1xuLmN1cnNvckhvdmVyLS0tQURDbjAge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IDIwcHg7XG4gIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gIGN1cnNvcjogY29sLXJlc2l6ZTtcbn1cbi5jdXJzb3JBY3RpdmUtLS11V1g3dyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxuLmN1cnNvci0tLU9SM0Y2IHtcbiAgaGVpZ2h0OiAxMDAlO1xuICB3aWR0aDogMXB4O1xuICBib3JkZXItcmlnaHQ6IDJweCBkYXNoZWQgcmdiYSgwIDAgMCAvIDIwJSk7XG4gIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG59XG4uaGFuZGxlLS0tek9Dem4ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IDZweDtcbiAgY3Vyc29yOiBjb2wtcmVzaXplO1xuICBwb2ludGVyLWV2ZW50czogYWxsO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjJzO1xuXG4gICY6aG92ZXIsXG4gICYuYWN0aXZlLS0tV1Y3a2kge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCAwIDAgLyAxMCUpO1xuICB9XG59XG4uY29udGFpbmVyLS0tb3BOOTMge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG59XG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL2xpYi9QYW5lc2V0L1BhbmVSZXNpemUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLDREQUE0RDtBQUM1RDtFQUNFLGtCQUFrQjtFQUNsQixZQUFZO0VBQ1osV0FBVztFQUNYLG1CQUFtQjtFQUNuQixrQkFBa0I7QUFDcEI7QUFFQTtFQUNFLGFBQWE7RUFDYix1QkFBdUI7QUFDekI7QUFFQTtFQUNFLFlBQVk7RUFDWixVQUFVO0VBQ1YsMENBQTBDO0VBQzFDLG1CQUFtQjtBQUNyQjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFlBQVk7RUFDWixVQUFVO0VBQ1Ysa0JBQWtCO0VBQ2xCLG1CQUFtQjtFQUNuQiw2QkFBNkI7RUFDN0IsaUNBQWlDOztFQUVqQzs7SUFFRSxtQ0FBbUM7RUFDckM7QUFDRjtBQUVBO0VBQ0Usb0JBQW9CO0VBQ3BCLFdBQVc7RUFDWCxZQUFZO0VBQ1osa0JBQWtCO0VBQ2xCLE1BQU07RUFDTixPQUFPO0FBQ1RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogd2lkZW5lZCBob3ZlciBhcmVhIHRvIGtlZXAgbW91c2UgY3Vyc29yIGZyb20gZmxpY2tlcmluZyAqL1xcbi5jdXJzb3JIb3ZlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMjBweDtcXG4gIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICBjdXJzb3I6IGNvbC1yZXNpemU7XFxufVxcblxcbi5jdXJzb3JBY3RpdmUge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4uY3Vyc29yIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxcHg7XFxuICBib3JkZXItcmlnaHQ6IDJweCBkYXNoZWQgcmdiYSgwIDAgMCAvIDIwJSk7XFxuICBhbGlnbi1zZWxmOiBzdHJldGNoO1xcbn1cXG5cXG4uaGFuZGxlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiA2cHg7XFxuICBjdXJzb3I6IGNvbC1yZXNpemU7XFxuICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMnM7XFxuXFxuICAmOmhvdmVyLFxcbiAgJi5hY3RpdmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAgMCAwIC8gMTAlKTtcXG4gIH1cXG59XFxuXFxuLmNvbnRhaW5lciB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiY3Vyc29ySG92ZXJcIjogYGN1cnNvckhvdmVyLS0tQURDbjBgLFxuXHRcImN1cnNvckFjdGl2ZVwiOiBgY3Vyc29yQWN0aXZlLS0tdVdYN3dgLFxuXHRcImN1cnNvclwiOiBgY3Vyc29yLS0tT1IzRjZgLFxuXHRcImhhbmRsZVwiOiBgaGFuZGxlLS0tek9Dem5gLFxuXHRcImFjdGl2ZVwiOiBgYWN0aXZlLS0tV1Y3a2lgLFxuXHRcImNvbnRhaW5lclwiOiBgY29udGFpbmVyLS0tb3BOOTNgXG59O1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/PaneResize.css\n\n}')},"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/Paneset.css"(module,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/css-loader/dist/runtime/sourceMaps.js");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/css-loader/dist/runtime/api.js");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n\n.paneset---hvDLJ {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  display: block;\n  will-change: transform;\n  overflow: hidden;\n\n  & .paneset---hvDLJ,\n  &.nested---jmTFb {\n    position: relative;\n  }\n\n  &.static---D8WPv {\n    position: static;\n  }\n\n  @media print {\n    display: block !important;\n    overflow: visible;\n    height: -moz-fit-content !important;\n    height: fit-content !important;\n\n    /* autosizer prefers containers of at least 1px */\n    min-height: 1px;\n  }\n}\n\n@media (min-width: 641px) {\n  .paneset---hvDLJ {\n    display: flex;\n    flex-direction: row;\n    align-items: stretch;\n    justify-content: flex-start;\n  }\n}\n`, "",{"version":3,"sources":["webpack://./lib/Paneset/Paneset.css"],"names":[],"mappings":";;AAEA;EACE,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,cAAc;EACd,sBAAsB;EACtB,gBAAgB;;EAEhB;;IAEE,kBAAkB;EACpB;;EAEA;IACE,gBAAgB;EAClB;;EAEA;IACE,yBAAyB;IACzB,iBAAiB;IACjB,mCAA8B;IAA9B,8BAA8B;;IAE9B,iDAAiD;IACjD,eAAe;EACjB;AACF;;AAEA;EACE;IACE,aAAa;IACb,mBAAmB;IACnB,oBAAoB;IACpB,2BAA2B;EAC7B;AACF","sourcesContent":["\\n\\n.paneset {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n  display: block;\\n  will-change: transform;\\n  overflow: hidden;\\n\\n  & .paneset,\\n  &.nested {\\n    position: relative;\\n  }\\n\\n  &.static {\\n    position: static;\\n  }\\n\\n  @media print {\\n    display: block !important;\\n    overflow: visible;\\n    height: fit-content !important;\\n\\n    /* autosizer prefers containers of at least 1px */\\n    min-height: 1px;\\n  }\\n}\\n\\n@media (--medium-up) {\\n  .paneset {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: stretch;\\n    justify-content: flex-start;\\n  }\\n}\\n"],"sourceRoot":""}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t"paneset": `paneset---hvDLJ`,\n\t"nested": `nested---jmTFb`,\n\t"static": `static---D8WPv`\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0udXNlWzJdIS4vbGliL1BhbmVzZXQvUGFuZXNldC5jc3MiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bmb2xpby9zdHJpcGVzLWNvbXBvbmVudHMvLi9saWIvUGFuZXNldC9QYW5lc2V0LmNzcz84YTU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBcblxuLnBhbmVzZXQtLS1odkRMSiB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgJiAucGFuZXNldC0tLWh2RExKLFxuICAmLm5lc3RlZC0tLWptVEZiIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cblxuICAmLnN0YXRpYy0tLUQ4V1B2IHtcbiAgICBwb3NpdGlvbjogc3RhdGljO1xuICB9XG5cbiAgQG1lZGlhIHByaW50IHtcbiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgIGhlaWdodDogLW1vei1maXQtY29udGVudCAhaW1wb3J0YW50O1xuICAgIGhlaWdodDogZml0LWNvbnRlbnQgIWltcG9ydGFudDtcblxuICAgIC8qIGF1dG9zaXplciBwcmVmZXJzIGNvbnRhaW5lcnMgb2YgYXQgbGVhc3QgMXB4ICovXG4gICAgbWluLWhlaWdodDogMXB4O1xuICB9XG59XG5cbkBtZWRpYSAobWluLXdpZHRoOiA2NDFweCkge1xuICAucGFuZXNldC0tLWh2RExKIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICB9XG59XG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL2xpYi9QYW5lc2V0L1BhbmVzZXQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsWUFBWTtFQUNaLGtCQUFrQjtFQUNsQixjQUFjO0VBQ2Qsc0JBQXNCO0VBQ3RCLGdCQUFnQjs7RUFFaEI7O0lBRUUsa0JBQWtCO0VBQ3BCOztFQUVBO0lBQ0UsZ0JBQWdCO0VBQ2xCOztFQUVBO0lBQ0UseUJBQXlCO0lBQ3pCLGlCQUFpQjtJQUNqQixtQ0FBOEI7SUFBOUIsOEJBQThCOztJQUU5QixpREFBaUQ7SUFDakQsZUFBZTtFQUNqQjtBQUNGOztBQUVBO0VBQ0U7SUFDRSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLG9CQUFvQjtJQUNwQiwyQkFBMkI7RUFDN0I7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJcXG5cXG4ucGFuZXNldCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuXFxuICAmIC5wYW5lc2V0LFxcbiAgJi5uZXN0ZWQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuXFxuICAmLnN0YXRpYyB7XFxuICAgIHBvc2l0aW9uOiBzdGF0aWM7XFxuICB9XFxuXFxuICBAbWVkaWEgcHJpbnQge1xcbiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgaGVpZ2h0OiBmaXQtY29udGVudCAhaW1wb3J0YW50O1xcblxcbiAgICAvKiBhdXRvc2l6ZXIgcHJlZmVycyBjb250YWluZXJzIG9mIGF0IGxlYXN0IDFweCAqL1xcbiAgICBtaW4taGVpZ2h0OiAxcHg7XFxuICB9XFxufVxcblxcbkBtZWRpYSAoLS1tZWRpdW0tdXApIHtcXG4gIC5wYW5lc2V0IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicGFuZXNldFwiOiBgcGFuZXNldC0tLWh2RExKYCxcblx0XCJuZXN0ZWRcIjogYG5lc3RlZC0tLWptVEZiYCxcblx0XCJzdGF0aWNcIjogYHN0YXRpYy0tLUQ4V1B2YFxufTtcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[8].use[2]!./lib/Paneset/Paneset.css\n\n}')}}]);