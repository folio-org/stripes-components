import React from 'react';
import { describe, beforeEach, it } from 'mocha';
import { expect } from 'chai';
import { Accordion as Interactor, Keyboard, Bigtest, runAxeTest, Button } from '@folio/stripes-testing';
import sinon from 'sinon';
import { mountWithContext } from '../../../tests/helpers';
import UsageWithAccordionSet from '../stories/BasicUsage';

import Accordion from '../Accordion';
import AccordionSet from '../AccordionSet';

const Focused = Button.extend('Accordion header')
  .selector(':focus')
  .actions({
    pressKey: async ({ perform }, key) => {
      await perform(async (e) => await Keyboard.pressKey(key))
    }
  });

describe('Accordion', () => {
  const accordion = Interactor('test');

  beforeEach(async () => {
    await mountWithContext(
      <Accordion label="test">
        <div style={{ height: 100 }}>
          Test Content.
        </div>
      </Accordion>
    );
  });

  it('has no axe errors', runAxeTest);

  it('is open by default', () => accordion.is({ open: true }));

  it('sets the appropriate content height', () => accordion.has({ contentHeight: 100 }));

  it('has a label', () => accordion.has({ label: 'test' }));

  describe('when closed', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" open={false}>
          <div style={{ height: 100 }}>
            Test Content.
          </div>
        </Accordion>
      );
    });

    it('content is hidden', () => accordion.has({ open: false }));
  });

  describe('clicking the header', () => {
    const onClickToggleSpy = sinon.spy();

    beforeEach(async () => {
      await mountWithContext(
        <Accordion
          id="test-id"
          label="test"
          onClickToggle={onClickToggleSpy}
        >
          <div style={{ height: 100 }}>
            Test Content.
          </div>
        </Accordion>
      );

      await accordion.clickHeader();
    });

    it('closes the accordion', () => accordion.is({ open: false }));

    it('calls onClickToggle with correct "open" state', async () => {
      await expect(onClickToggleSpy.calledWith({
        id: 'test-id',
        label: 'test',
        open: false,
      })).to.be.true;
    });

    describe('clicking the header again', () => {
      beforeEach(async () => {
        await accordion.clickHeader()
      });

      it('opens the accordion', () => accordion.is({ open: true }));

      it('calls onClickToggle with correct "open" state', async () => {
        await expect(onClickToggleSpy.calledWith({
          id: 'test-id',
          label: 'test',
          open: true,
        })).to.be.true;
      });
    });
  });

  describe('when the accordion is closed by default', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" closedByDefault>
          <div style={{ height: 100 }}>
            Test Content
          </div>
        </Accordion>
      );
    });

    it('has no axe errors', runAxeTest);

    it('is closed by default', () => accordion.is({ open: false }));

    describe('clicking the header', () => {
      beforeEach(async () => {
        await accordion.clickHeader();
      });

      it('opens the accordion', () => accordion.is({ open: true }));

      describe('clicking the header again', () => {
        beforeEach(async () => {
          await accordion.clickHeader()
        });

        it('closes the accordion', () => accordion.is({ open: false }));
      });
    });
  });

  describe('with an id', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" id="accordion-test">
          <div style={{ height: 100 }} />
        </Accordion>
      );
    });

    it('has an id on the root element', () => accordion.has({ id: 'accordion-test' }));

    it('is open by default', () => accordion.is({ open: true }));
  });

  describe('with a content id', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" open contentId="content-test">
          <div style={{ height: 100 }} />
        </Accordion>
      );
    });

    it('has an id on the accordion-wrapper element', () => accordion.has({ contentId: 'content-test' }));
  });

  describe('without a content id', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test">
          <div style={{ height: 100 }} />
        </Accordion>
      );
    });

    it('creates an id on the accordion-wrapper element', async () => {
      await accordion.has({ contentId: '@@autogenerated@@' });
    });
  });

  describe('onToggle callback', () => {
    const testToggle = sinon.spy();
    beforeEach(async () => {
      await mountWithContext(
        <Accordion
          id="testId"
          label="test"
          onToggle={testToggle}
          open
        >
          <div style={{ height: 100 }}>
            Test Content.
          </div>
        </Accordion>
      );
    });

    describe('clicking the header', () => {
      beforeEach(async () => {
        await accordion.clickHeader();
      });

      it('supplies id and label parameters to onToggle()', async () => {
        await testToggle.withArgs({ id: 'testId', label: 'test' }).calledOnce;
      });
    });
  });
});

  describe('Accordion - as part of an AccordionSet', () => {
    const first = Interactor({ index: 0 });
    const second = Interactor({ index: 1 });
    const last = Interactor({ index: 3 });

    beforeEach(async () => {
      await mountWithContext(
        <AccordionSet initialStatus={{
          test1: false,
          test2: true,
          test3: true,
          test4: true,
        }}>
          <Accordion label="test1" id="test1">
            <input aria-label="test1" type="text" id="testControl1" />
          </Accordion>
          <Accordion label="test2" id="test2">
            <input aria-label="test2" />
          </Accordion>
          <Accordion label="test3" id="test3">
            <input aria-label="test3" />
          </Accordion>
          <Accordion label="test4" id="test4">
            <input aria-label="test4" />
          </Accordion>
        </AccordionSet>
      );
    });

    it('has no axe errors', () => runAxeTest);

    it('has a button', () => Button('test1').exists());

    describe('contents ready for interaction following open', () => {
      beforeEach(async () => {
        await first.clickHeader();
        await Bigtest.TextField({id: 'testControl1', }).fillIn("test");
      });

      it('Child element was filled out successfully', () => Bigtest.TextField({id: 'testControl1'}).has({ value: "test" }));
    });

    describe('keyboard navigation: next accordion', () => {
      beforeEach(async () => {
        await first.focus();
        await Focused('test1').pressKey('ArrowDown');
      });

      it('second accordion is in focus', async () => await second.is({ focused: true }));
    });

    describe('keyboard navigation: previous accordion', () => {
      beforeEach(async () => {
        await second.focus();
        await Focused('test2').pressKey('ArrowUp');
      });

      it('first accordion is in focus', async () => await first.is({ focused: true }));
    });

    describe('keyboard navigation: last accordion', () => {
      beforeEach(async () => {
        await first.focus();
        await Focused('test1').pressKey('End');
      });

      it('Last accordion is in focus', async () => await last.is({ focused: true }));
    });

    describe('keyboard navigation: first accordion', () => {
      beforeEach(async () => {
        await last.focus();
        await Focused('test4').pressKey('Home');
      });

      it('First accordion is in focus', async () => await first.is({ focused: true }));
    });
  });

  describe('Accordion - updating state of parent component', () => {
    const first = Interactor({ index: 0 });
    const second = Interactor({ index: 1 });
    const last = Interactor({ index: 3 });
    const textField = Bigtest.TextField({ id: 'testTextField' });
    beforeEach(async () => {
      await mountWithContext(<UsageWithAccordionSet/>)
    });

    it('renders second accordion as closed', () => second.is({ open: false }));
    it('renders a blank textfield', () => textField.has({ value: ''}));

    describe('opening the closed accordion', () => {
      beforeEach(async () => {
        await second.clickHeader();
      });

      it('renders second accordion as open', () => second.is({ open: true }));

      describe('changing the text value/parent state', () => {
        beforeEach(async () => {
          await textField.fillIn('test');
        });

        it('renders state value in textField', () => textField.has({ value: 'test' }));
        it('renders second accordion as open', () => second.is({ open: true }));
      });
    });
  });