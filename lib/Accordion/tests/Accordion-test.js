import React, { useState } from 'react';
import { describe, beforeEach, it } from 'mocha';
import { expect } from 'chai';
import { Accordion as Interactor, Keyboard, Bigtest, runAxeTest, Button } from '@folio/stripes-testing';
import sinon from 'sinon';
import { mountWithContext } from '../../../tests/helpers';
import UsageWithAccordionSet from '../stories/BasicUsage';

import Accordion from '../Accordion';
import AccordionSet from '../AccordionSet';
import { FilterAccordionHeader } from '../headers';

const Focused = Button.extend('Accordion header')
  .selector(':focus')
  .actions({
    pressKey: async ({ perform }, key) => {
      await perform(async () => Keyboard.pressKey(key))
    }
  });

describe('Accordion', () => {
  const accordion = Interactor('test');

  beforeEach(async () => {
    await mountWithContext(
      <Accordion label="test">
        <div style={{ height: 100 }}>
          Test Content.
        </div>
      </Accordion>
    );
  });

  it('has no axe errors', runAxeTest);

  it('is open by default', () => accordion.is({ open: true }));

  it('sets the appropriate content height', () => accordion.has({ contentHeight: 100 }));

  it('has a label', () => accordion.has({ label: 'test' }));

  describe('when closed', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" open={false}>
          <div style={{ height: 100 }}>
            Test Content.
          </div>
        </Accordion>
      );
    });

    it('content is hidden', () => accordion.has({ open: false }));
  });

  describe('clicking the header', () => {
    const onClickToggleSpy = sinon.spy();

    beforeEach(async () => {
      await mountWithContext(
        <Accordion
          id="test-id"
          label="test"
          onClickToggle={onClickToggleSpy}
        >
          <div style={{ height: 100 }}>
            Test Content.
          </div>
        </Accordion>
      );

      await accordion.clickHeader();
    });

    it('closes the accordion', () => accordion.is({ open: false }));

    it('calls onClickToggle with correct "open" state', async () => {
      await expect(onClickToggleSpy.calledWith({
        id: 'test-id',
        label: 'test',
        open: false,
      })).to.be.true;
    });

    describe('clicking the header again', () => {
      beforeEach(async () => {
        await accordion.clickHeader()
      });

      it('opens the accordion', () => accordion.is({ open: true }));

      it('calls onClickToggle with correct "open" state', async () => {
        await expect(onClickToggleSpy.calledWith({
          id: 'test-id',
          label: 'test',
          open: true,
        })).to.be.true;
      });
    });
  });

  describe('when the accordion is closed by default', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" closedByDefault>
          <div style={{ height: 100 }}>
            Test Content
          </div>
        </Accordion>
      );
    });

    it('has no axe errors', runAxeTest);

    it('is closed by default', () => accordion.is({ open: false }));

    describe('clicking the header', () => {
      beforeEach(async () => {
        await accordion.clickHeader();
      });

      it('opens the accordion', () => accordion.is({ open: true }));

      describe('clicking the header again', () => {
        beforeEach(async () => {
          await accordion.clickHeader()
        });

        it('closes the accordion', () => accordion.is({ open: false }));
      });
    });
  });

  describe('with an id', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" id="accordion-test">
          <div style={{ height: 100 }} />
        </Accordion>
      );
    });

    it('has an id on the root element', () => accordion.has({ id: 'accordion-test' }));

    it('is open by default', () => accordion.is({ open: true }));
  });

  describe('with a content id', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test" open contentId="content-test">
          <div style={{ height: 100 }} />
        </Accordion>
      );
    });

    it('has an id on the accordion-wrapper element', () => accordion.has({ contentId: 'content-test' }));
  });

  describe('without a content id', () => {
    beforeEach(async () => {
      await mountWithContext(
        <Accordion label="test">
          <div style={{ height: 100 }} />
        </Accordion>
      );
    });

    it('creates an id on the accordion-wrapper element', async () => {
      await accordion.has({ contentId: '@@autogenerated@@' });
    });
  });

  describe('onToggle callback', () => {
    const testToggle = sinon.spy();
    beforeEach(async () => {
      await mountWithContext(
        <Accordion
          id="testId"
          label="test"
          onToggle={testToggle}
          open
        >
          <div style={{ height: 100 }}>
            Test Content.
          </div>
        </Accordion>
      );
    });

    describe('clicking the header', () => {
      beforeEach(async () => {
        await accordion.clickHeader();
      });

      it('supplies id and label parameters to onToggle()', async () => {
        await testToggle.withArgs({ id: 'testId', label: 'test' }).calledOnce;
      });
    });
  });
});

describe('Accordion - as part of an AccordionSet', () => {
  const first = Interactor({ index: 0 });
  const second = Interactor({ index: 1 });
  const last = Interactor({ index: 3 });

  const onRegisterAccordionSpy = sinon.spy();

  beforeEach(async () => {
    await mountWithContext(
      <AccordionSet
        initialStatus={{
          test1: false,
          test2: true,
          test3: true,
          test4: true,
        }}
        onRegisterAccordion={onRegisterAccordionSpy}
      >
        <Accordion label="test1" id="test1">
          <input aria-label="test1" type="text" id="testControl1" />
        </Accordion>
        <Accordion label="test2" id="test2">
          <input aria-label="test2" />
        </Accordion>
        <Accordion label="test3" id="test3">
          <input aria-label="test3" />
        </Accordion>
        <Accordion label="test4" id="test4">
          <input aria-label="test4" />
        </Accordion>
      </AccordionSet>
    );
  });

  it('has no axe errors', () => runAxeTest);

  it('has a button', () => Button('test1').exists());

  it('should call onRegisterAccordion callback', () => {
    return expect(onRegisterAccordionSpy.calledWith('test1')).to.be.true;
  });

  describe('contents ready for interaction following open', () => {
    beforeEach(async () => {
      await first.clickHeader();
      await Bigtest.TextField({ id: 'testControl1' }).fillIn('test');
    });

    it('Child element was filled out successfully', () => Bigtest.TextField({id: 'testControl1'}).has({ value: 'test' }));
  });

  describe('keyboard navigation: next accordion', () => {
    beforeEach(async () => {
      await first.focus();
      await Focused('test1').pressKey('ArrowDown');
    });

    it('second accordion is in focus', async () => second.is({ focused: true }));
  });

  describe('keyboard navigation: previous accordion', () => {
    beforeEach(async () => {
      await second.focus();
      await Focused('test2').pressKey('ArrowUp');
    });

    it('first accordion is in focus', async () => first.is({ focused: true }));
  });

  describe('keyboard navigation: last accordion', () => {
    beforeEach(async () => {
      await first.focus();
      await Focused('test1').pressKey('End');
    });

    it('Last accordion is in focus', async () => last.is({ focused: true }));
  });

  describe('keyboard navigation: first accordion', () => {
    beforeEach(async () => {
      await last.focus();
      await Focused('test4').pressKey('Home');
    });

    it('First accordion is in focus', async () => first.is({ focused: true }));
  });
});

describe('Accordion - with FilterAccordionHeader', () => {
  const first = Interactor({ index: 0 });
  const second = Interactor({ index: 1 });
  const last = Interactor({ index: 3 });

  const onRegisterAccordionSpy = sinon.spy();

  beforeEach(async () => {
    await mountWithContext(
      <AccordionSet
        initialStatus={{
          test1: false,
          test2: true,
          test3: true,
          test4: true,
        }}
        onRegisterAccordion={onRegisterAccordionSpy}
      >
        <Accordion label="test1" id="test1" header={FilterAccordionHeader}>
          <input aria-label="test1" type="text" id="testControl1" />
        </Accordion>
        <Accordion label="test2" id="test2" header={FilterAccordionHeader}>
          <input aria-label="test2" />
        </Accordion>
        <Accordion label="test3" id="test3" header={FilterAccordionHeader}>
          <input aria-label="test3" />
        </Accordion>
        <Accordion label="test4" id="test4" header={FilterAccordionHeader}>
          <input aria-label="test4" />
        </Accordion>
      </AccordionSet>
    );
  });

  it('has no axe errors', () => runAxeTest);

  it('has a button', () => Button('test1').exists());

  it('should call onRegisterAccordion callback', () => {
    return expect(onRegisterAccordionSpy.calledWith('test1')).to.be.true;
  });

  describe('contents ready for interaction following open', () => {
    beforeEach(async () => {
      await first.clickHeader();
      await Bigtest.TextField({ id: 'testControl1' }).fillIn('test');
    });

    it('Child element was filled out successfully', () => Bigtest.TextField({id: 'testControl1'}).has({ value: 'test' }));
  });

  describe('keyboard navigation: next accordion', () => {
    beforeEach(async () => {
      await first.focus();
      await Focused('test1').pressKey('ArrowDown');
    });

    it('second accordion is in focus', async () => second.is({ focused: true }));
  });

  describe('keyboard navigation: previous accordion', () => {
    beforeEach(async () => {
      await second.focus();
      await Focused('test2').pressKey('ArrowUp');
    });

    it('first accordion is in focus', async () => first.is({ focused: true }));
  });

  describe('keyboard navigation: last accordion', () => {
    beforeEach(async () => {
      await first.focus();
      await Focused('test1').pressKey('End');
    });

    it('Last accordion is in focus', async () => last.is({ focused: true }));
  });

  describe('keyboard navigation: first accordion', () => {
    beforeEach(async () => {
      await last.focus();
      await Focused('test4').pressKey('Home');
    });

    it('First accordion is in focus', async () => first.is({ focused: true }));
  });
});

describe('unmounting Accordion - as part of an AccordionSet', () => {
  const onUnregisterAccordionSpy = sinon.spy();

  const Wrapper = () => {
    const [renderAccordion, setRenderAccordion] = useState(true);

    return (
      <>
        <AccordionSet
          initialStatus={{
            test1: true,
          }}
          onUnregisterAccordion={onUnregisterAccordionSpy}
        >
          {renderAccordion && (
            <Accordion label="test1" id="test1">
              <input aria-label="test1" type="text" id="testControl1" />
            </Accordion>
          )}
        </AccordionSet>
        <button type="button" onClick={() => setRenderAccordion(false)}>Unmount accordion</button>
      </>
    );
  };

  const first = Interactor({ index: 0 });
  const unmountAccordionButton = Button('Unmount accordion');

  beforeEach(async () => {
    await mountWithContext(<Wrapper />);
  });

  it('should call onUnregisterAccordion callback', async () => {
    await first.is({ open: true });
    await unmountAccordionButton.click();

    return expect(onUnregisterAccordionSpy.calledWith('test1')).to.be.true;
  });
});

describe('Accordion - updating state of parent component', () => {
  const first = Interactor({ index: 0 });
  const second = Interactor({ index: 1 });
  const last = Interactor({ index: 3 });
  const textField = Bigtest.TextField({ id: 'testTextField' });
  beforeEach(async () => {
    await mountWithContext(<UsageWithAccordionSet />)
  });

  it('renders second accordion as closed', () => second.is({ open: false }));
  it('renders a blank textfield', () => textField.has({ value: ''}));

  describe('opening the closed accordion', () => {
    beforeEach(async () => {
      await second.clickHeader();
    });

    it('renders second accordion as open', () => second.is({ open: true }));

    describe('changing the text value/parent state', () => {
      beforeEach(async () => {
        await textField.fillIn('test');
      });

      it('renders state value in textField', () => textField.has({ value: 'test' }));
      it('renders second accordion as open', () => second.is({ open: true }));
    });
  });
});
